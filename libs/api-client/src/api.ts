/* tslint:disable */
/* eslint-disable */
/**
 * Common API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { AxiosInstance, AxiosPromise, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
import type { Configuration } from './configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import type { RequestArgs } from './base';
import {
  DUMMY_BASE_URL,
  assertParamExists,
  createRequestFunction,
  serializeDataIfNeeded,
  setOAuthToObject,
  setSearchParams,
  toPathString,
} from './common';
// @ts-ignore
import { BASE_PATH, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 *
 * @export
 * @interface CommunityCreateGroupRequest
 */
export interface CommunityCreateGroupRequest {
  /**
   *
   * @type {CommunityCreateGroupRequestMetadata}
   * @memberof CommunityCreateGroupRequest
   */
  metadata: CommunityCreateGroupRequestMetadata;
  /**
   *
   * @type {Array<CommunityGetCommunity200ResponseGroupsInnerRequirementsInner>}
   * @memberof CommunityCreateGroupRequest
   */
  requirements: Array<CommunityGetCommunity200ResponseGroupsInnerRequirementsInner>;
  /**
   *
   * @type {Array<number>}
   * @memberof CommunityCreateGroupRequest
   */
  topics?: Array<number>;
}
/**
 *
 * @export
 * @interface CommunityCreateGroupRequestMetadata
 */
export interface CommunityCreateGroupRequestMetadata {
  /**
   *
   * @type {string}
   * @memberof CommunityCreateGroupRequestMetadata
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof CommunityCreateGroupRequestMetadata
   */
  description: string;
  /**
   *
   * @type {number}
   * @memberof CommunityCreateGroupRequestMetadata
   */
  required_requirements?: number;
  /**
   *
   * @type {number}
   * @memberof CommunityCreateGroupRequestMetadata
   */
  membership_ttl?: number;
}
/**
 *
 * @export
 * @interface CommunityCreateStakeTransactionRequest
 */
export interface CommunityCreateStakeTransactionRequest {
  /**
   *
   * @type {string}
   * @memberof CommunityCreateStakeTransactionRequest
   */
  transaction_hash: string;
  /**
   *
   * @type {string}
   * @memberof CommunityCreateStakeTransactionRequest
   */
  community_id: string;
}
/**
 *
 * @export
 * @interface CommunityGetCommunity200Response
 */
export interface CommunityGetCommunity200Response {
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200Response
   */
  name: string;
  /**
   *
   * @type {number}
   * @memberof CommunityGetCommunity200Response
   */
  chain_node_id: number;
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200Response
   */
  default_symbol?: string;
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200Response
   */
  network?: CommunityGetCommunity200ResponseNetworkEnum;
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200Response
   */
  base: CommunityGetCommunity200ResponseBaseEnum;
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200Response
   */
  icon_url?: string | null;
  /**
   *
   * @type {boolean}
   * @memberof CommunityGetCommunity200Response
   */
  active: boolean;
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200Response
   */
  type?: CommunityGetCommunity200ResponseTypeEnum;
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200Response
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200Response
   */
  description?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof CommunityGetCommunity200Response
   */
  social_links?: Array<string>;
  /**
   *
   * @type {number}
   * @memberof CommunityGetCommunity200Response
   */
  ss58_prefix?: number;
  /**
   *
   * @type {boolean}
   * @memberof CommunityGetCommunity200Response
   */
  stages_enabled?: boolean;
  /**
   *
   * @type {Array<string>}
   * @memberof CommunityGetCommunity200Response
   */
  custom_stages?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200Response
   */
  custom_domain?: string;
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200Response
   */
  block_explorer_ids?: string;
  /**
   *
   * @type {boolean}
   * @memberof CommunityGetCommunity200Response
   */
  collapsed_on_homepage?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof CommunityGetCommunity200Response
   */
  has_chain_events_listener?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof CommunityGetCommunity200Response
   */
  default_summary_view?: boolean;
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200Response
   */
  default_page?: CommunityGetCommunity200ResponseDefaultPageEnum;
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200Response
   */
  has_homepage?: CommunityGetCommunity200ResponseHasHomepageEnum | null;
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200Response
   */
  terms?: string;
  /**
   *
   * @type {boolean}
   * @memberof CommunityGetCommunity200Response
   */
  admin_only_polling?: boolean;
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200Response
   */
  bech32_prefix?: string;
  /**
   *
   * @type {boolean}
   * @memberof CommunityGetCommunity200Response
   */
  hide_projects?: boolean;
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200Response
   */
  token_name?: string;
  /**
   *
   * @type {boolean}
   * @memberof CommunityGetCommunity200Response
   */
  ce_verbose?: boolean;
  /**
   *
   * @type {number}
   * @memberof CommunityGetCommunity200Response
   */
  discord_config_id?: number | null;
  /**
   *
   * @type {any}
   * @memberof CommunityGetCommunity200Response
   */
  category?: any;
  /**
   *
   * @type {boolean}
   * @memberof CommunityGetCommunity200Response
   */
  discord_bot_webhooks_enabled?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof CommunityGetCommunity200Response
   */
  directory_page_enabled?: boolean;
  /**
   *
   * @type {number}
   * @memberof CommunityGetCommunity200Response
   */
  directory_page_chain_node_id?: number;
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200Response
   */
  namespace?: string;
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200Response
   */
  namespace_address?: string;
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200Response
   */
  redirect?: string;
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200Response
   */
  created_at?: string;
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200Response
   */
  updated_at?: string;
  /**
   *
   * @type {Array<CommunityGetCommunity200ResponseAddressesInner>}
   * @memberof CommunityGetCommunity200Response
   */
  Addresses?: Array<CommunityGetCommunity200ResponseAddressesInner>;
  /**
   *
   * @type {Array<CommunityGetCommunity200ResponseCommunityStakesInner>}
   * @memberof CommunityGetCommunity200Response
   */
  CommunityStakes?: Array<CommunityGetCommunity200ResponseCommunityStakesInner>;
  /**
   *
   * @type {Array<CommunityGetCommunity200ResponseCommunityTagsInner>}
   * @memberof CommunityGetCommunity200Response
   */
  CommunityTags?: Array<CommunityGetCommunity200ResponseCommunityTagsInner>;
  /**
   *
   * @type {CommunityGetCommunity200ResponseChainNode}
   * @memberof CommunityGetCommunity200Response
   */
  ChainNode?: CommunityGetCommunity200ResponseChainNode;
  /**
   *
   * @type {Array<CommunityGetCommunity200ResponseTopicsInner>}
   * @memberof CommunityGetCommunity200Response
   */
  topics?: Array<CommunityGetCommunity200ResponseTopicsInner>;
  /**
   *
   * @type {Array<CommunityGetCommunity200ResponseGroupsInner>}
   * @memberof CommunityGetCommunity200Response
   */
  groups?: Array<CommunityGetCommunity200ResponseGroupsInner>;
  /**
   *
   * @type {Array<CommunityGetCommunity200ResponseContestManagersInner>}
   * @memberof CommunityGetCommunity200Response
   */
  contest_managers?: Array<CommunityGetCommunity200ResponseContestManagersInner>;
  /**
   *
   * @type {Array<string>}
   * @memberof CommunityGetCommunity200Response
   */
  snapshot_spaces?: Array<string>;
  /**
   *
   * @type {boolean}
   * @memberof CommunityGetCommunity200Response
   */
  include_in_digest_email?: boolean | null;
}

export const CommunityGetCommunity200ResponseNetworkEnum = {
  Edgeware: 'edgeware',
  EdgewareTestnet: 'edgeware-testnet',
  Kusama: 'kusama',
  Kulupu: 'kulupu',
  Polkadot: 'polkadot',
  Plasm: 'plasm',
  Stafi: 'stafi',
  Darwinia: 'darwinia',
  Phala: 'phala',
  Centrifuge: 'centrifuge',
  Straightedge: 'straightedge',
  Osmosis: 'osmosis',
  Injective: 'injective',
  InjectiveTestnet: 'injective-testnet',
  Terra: 'terra',
  Ethereum: 'ethereum',
  Near: 'near',
  NearTestnet: 'near-testnet',
  Compound: 'compound',
  Aave: 'aave',
  AaveLocal: 'aave-local',
  Dydx: 'dydx',
  Metacartel: 'metacartel',
  Alex: 'alex',
  Erc20: 'erc20',
  Erc721: 'erc721',
  Erc1155: 'erc1155',
  Cw20: 'cw20',
  Cw721: 'cw721',
  Clover: 'clover',
  Hydradx: 'hydradx',
  Crust: 'crust',
  Sputnik: 'sputnik',
  SolanaDevnet: 'solana-devnet',
  SolanaTestnet: 'solana-testnet',
  Solana: 'solana',
  Spl: 'spl',
  Evmos: 'evmos',
  Kava: 'kava',
  Kyve: 'kyve',
  Stargaze: 'stargaze',
  Cosmos: 'cosmos',
} as const;

export type CommunityGetCommunity200ResponseNetworkEnum =
  typeof CommunityGetCommunity200ResponseNetworkEnum[keyof typeof CommunityGetCommunity200ResponseNetworkEnum];
export const CommunityGetCommunity200ResponseBaseEnum = {
  Cosmos: 'cosmos',
  Substrate: 'substrate',
  Ethereum: 'ethereum',
  Near: 'near',
  Solana: 'solana',
} as const;

export type CommunityGetCommunity200ResponseBaseEnum =
  typeof CommunityGetCommunity200ResponseBaseEnum[keyof typeof CommunityGetCommunity200ResponseBaseEnum];
export const CommunityGetCommunity200ResponseTypeEnum = {
  Chain: 'chain',
  Dao: 'dao',
  Token: 'token',
  Offchain: 'offchain',
} as const;

export type CommunityGetCommunity200ResponseTypeEnum =
  typeof CommunityGetCommunity200ResponseTypeEnum[keyof typeof CommunityGetCommunity200ResponseTypeEnum];
export const CommunityGetCommunity200ResponseDefaultPageEnum = {
  AllDiscussionsView: 'default_all_discussions_view',
  SummaryView: 'default_summary_view',
} as const;

export type CommunityGetCommunity200ResponseDefaultPageEnum =
  typeof CommunityGetCommunity200ResponseDefaultPageEnum[keyof typeof CommunityGetCommunity200ResponseDefaultPageEnum];
export const CommunityGetCommunity200ResponseHasHomepageEnum = {
  True: 'true',
  False: 'false',
} as const;

export type CommunityGetCommunity200ResponseHasHomepageEnum =
  typeof CommunityGetCommunity200ResponseHasHomepageEnum[keyof typeof CommunityGetCommunity200ResponseHasHomepageEnum];

/**
 *
 * @export
 * @interface CommunityGetCommunity200ResponseAddressesInner
 */
export interface CommunityGetCommunity200ResponseAddressesInner {
  /**
   *
   * @type {number}
   * @memberof CommunityGetCommunity200ResponseAddressesInner
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200ResponseAddressesInner
   */
  address: string;
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200ResponseAddressesInner
   */
  community_id?: string;
  /**
   *
   * @type {number}
   * @memberof CommunityGetCommunity200ResponseAddressesInner
   */
  user_id?: number | null;
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200ResponseAddressesInner
   */
  verification_token?: string;
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200ResponseAddressesInner
   */
  verification_token_expires?: string | null;
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200ResponseAddressesInner
   */
  verified?: string | null;
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200ResponseAddressesInner
   */
  last_active?: string | null;
  /**
   *
   * @type {boolean}
   * @memberof CommunityGetCommunity200ResponseAddressesInner
   */
  ghost_address?: boolean;
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200ResponseAddressesInner
   */
  wallet_id?: CommunityGetCommunity200ResponseAddressesInnerWalletIdEnum;
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200ResponseAddressesInner
   */
  block_info?: string;
  /**
   *
   * @type {boolean}
   * @memberof CommunityGetCommunity200ResponseAddressesInner
   */
  is_user_default?: boolean;
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200ResponseAddressesInner
   */
  role?: CommunityGetCommunity200ResponseAddressesInnerRoleEnum;
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200ResponseAddressesInner
   */
  wallet_sso_source?: CommunityGetCommunity200ResponseAddressesInnerWalletSsoSourceEnum;
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200ResponseAddressesInner
   */
  hex?: string;
  /**
   *
   * @type {any}
   * @memberof CommunityGetCommunity200ResponseAddressesInner
   */
  created_at?: any;
  /**
   *
   * @type {any}
   * @memberof CommunityGetCommunity200ResponseAddressesInner
   */
  updated_at?: any;
  /**
   *
   * @type {UserUpdateUser200Response}
   * @memberof CommunityGetCommunity200ResponseAddressesInner
   */
  User?: UserUpdateUser200Response;
}

export const CommunityGetCommunity200ResponseAddressesInnerWalletIdEnum = {
  Magic: 'magic',
  Polkadot: 'polkadot',
  Metamask: 'metamask',
  Walletconnect: 'walletconnect',
  KeplrEthereum: 'keplr-ethereum',
  Keplr: 'keplr',
  Leap: 'leap',
  Near: 'near',
  Terrastation: 'terrastation',
  TerraWalletconnect: 'terra-walletconnect',
  CosmMetamask: 'cosm-metamask',
  Phantom: 'phantom',
  Coinbase: 'coinbase',
} as const;

export type CommunityGetCommunity200ResponseAddressesInnerWalletIdEnum =
  typeof CommunityGetCommunity200ResponseAddressesInnerWalletIdEnum[keyof typeof CommunityGetCommunity200ResponseAddressesInnerWalletIdEnum];
export const CommunityGetCommunity200ResponseAddressesInnerRoleEnum = {
  Admin: 'admin',
  Moderator: 'moderator',
  Member: 'member',
} as const;

export type CommunityGetCommunity200ResponseAddressesInnerRoleEnum =
  typeof CommunityGetCommunity200ResponseAddressesInnerRoleEnum[keyof typeof CommunityGetCommunity200ResponseAddressesInnerRoleEnum];
export const CommunityGetCommunity200ResponseAddressesInnerWalletSsoSourceEnum =
  {
    Google: 'google',
    Github: 'github',
    Discord: 'discord',
    Twitter: 'twitter',
    Apple: 'apple',
    Email: 'email',
    Unknown: 'unknown',
  } as const;

export type CommunityGetCommunity200ResponseAddressesInnerWalletSsoSourceEnum =
  typeof CommunityGetCommunity200ResponseAddressesInnerWalletSsoSourceEnum[keyof typeof CommunityGetCommunity200ResponseAddressesInnerWalletSsoSourceEnum];

/**
 *
 * @export
 * @interface CommunityGetCommunity200ResponseChainNode
 */
export interface CommunityGetCommunity200ResponseChainNode {
  /**
   *
   * @type {number}
   * @memberof CommunityGetCommunity200ResponseChainNode
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200ResponseChainNode
   */
  url: string;
  /**
   *
   * @type {number}
   * @memberof CommunityGetCommunity200ResponseChainNode
   */
  eth_chain_id?: number;
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200ResponseChainNode
   */
  alt_wallet_url?: string;
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200ResponseChainNode
   */
  private_url?: string;
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200ResponseChainNode
   */
  balance_type: CommunityGetCommunity200ResponseChainNodeBalanceTypeEnum;
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200ResponseChainNode
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200ResponseChainNode
   */
  description?: string;
  /**
   *
   * @type {number}
   * @memberof CommunityGetCommunity200ResponseChainNode
   */
  ss58?: number;
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200ResponseChainNode
   */
  bech32?: string;
  /**
   *
   * @type {number}
   * @memberof CommunityGetCommunity200ResponseChainNode
   */
  slip44?: number;
  /**
   *
   * @type {any}
   * @memberof CommunityGetCommunity200ResponseChainNode
   */
  created_at?: any;
  /**
   *
   * @type {any}
   * @memberof CommunityGetCommunity200ResponseChainNode
   */
  updated_at?: any;
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200ResponseChainNode
   */
  cosmos_chain_id?: string;
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200ResponseChainNode
   */
  cosmos_gov_version?: CommunityGetCommunity200ResponseChainNodeCosmosGovVersionEnum;
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200ResponseChainNode
   */
  health?: CommunityGetCommunity200ResponseChainNodeHealthEnum;
  /**
   *
   * @type {Array<CommunityGetCommunity200ResponseChainNodeContractsInner>}
   * @memberof CommunityGetCommunity200ResponseChainNode
   */
  contracts?: Array<CommunityGetCommunity200ResponseChainNodeContractsInner>;
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200ResponseChainNode
   */
  block_explorer?: string;
  /**
   *
   * @type {number}
   * @memberof CommunityGetCommunity200ResponseChainNode
   */
  max_ce_block_range?: number | null;
}

export const CommunityGetCommunity200ResponseChainNodeBalanceTypeEnum = {
  Terra: 'terra',
  Ethereum: 'ethereum',
  Solana: 'solana',
  Cosmos: 'cosmos',
  Near: 'near',
  Substrate: 'substrate',
} as const;

export type CommunityGetCommunity200ResponseChainNodeBalanceTypeEnum =
  typeof CommunityGetCommunity200ResponseChainNodeBalanceTypeEnum[keyof typeof CommunityGetCommunity200ResponseChainNodeBalanceTypeEnum];
export const CommunityGetCommunity200ResponseChainNodeCosmosGovVersionEnum = {
  V1: 'v1',
  V1beta1: 'v1beta1',
  V1beta1AttemptFailed: 'v1beta1-attempt-failed',
  V1AttemptFailed: 'v1-attempt-failed',
} as const;

export type CommunityGetCommunity200ResponseChainNodeCosmosGovVersionEnum =
  typeof CommunityGetCommunity200ResponseChainNodeCosmosGovVersionEnum[keyof typeof CommunityGetCommunity200ResponseChainNodeCosmosGovVersionEnum];
export const CommunityGetCommunity200ResponseChainNodeHealthEnum = {
  Failed: 'failed',
  Healthy: 'healthy',
} as const;

export type CommunityGetCommunity200ResponseChainNodeHealthEnum =
  typeof CommunityGetCommunity200ResponseChainNodeHealthEnum[keyof typeof CommunityGetCommunity200ResponseChainNodeHealthEnum];

/**
 *
 * @export
 * @interface CommunityGetCommunity200ResponseChainNodeContractsInner
 */
export interface CommunityGetCommunity200ResponseChainNodeContractsInner {
  /**
   *
   * @type {number}
   * @memberof CommunityGetCommunity200ResponseChainNodeContractsInner
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200ResponseChainNodeContractsInner
   */
  address: string;
  /**
   *
   * @type {number}
   * @memberof CommunityGetCommunity200ResponseChainNodeContractsInner
   */
  chain_node_id: number;
  /**
   *
   * @type {number}
   * @memberof CommunityGetCommunity200ResponseChainNodeContractsInner
   */
  abi_id?: number | null;
  /**
   *
   * @type {number}
   * @memberof CommunityGetCommunity200ResponseChainNodeContractsInner
   */
  decimals?: number;
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200ResponseChainNodeContractsInner
   */
  token_name?: string;
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200ResponseChainNodeContractsInner
   */
  symbol?: string;
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200ResponseChainNodeContractsInner
   */
  type: string;
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200ResponseChainNodeContractsInner
   */
  created_at: string;
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200ResponseChainNodeContractsInner
   */
  updated_at: string;
  /**
   *
   * @type {boolean}
   * @memberof CommunityGetCommunity200ResponseChainNodeContractsInner
   */
  is_factory?: boolean;
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200ResponseChainNodeContractsInner
   */
  nickname?: string;
}
/**
 *
 * @export
 * @interface CommunityGetCommunity200ResponseCommunityStakesInner
 */
export interface CommunityGetCommunity200ResponseCommunityStakesInner {
  /**
   *
   * @type {number}
   * @memberof CommunityGetCommunity200ResponseCommunityStakesInner
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200ResponseCommunityStakesInner
   */
  community_id: string;
  /**
   *
   * @type {number}
   * @memberof CommunityGetCommunity200ResponseCommunityStakesInner
   */
  stake_id?: number;
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200ResponseCommunityStakesInner
   */
  stake_token?: string;
  /**
   *
   * @type {number}
   * @memberof CommunityGetCommunity200ResponseCommunityStakesInner
   */
  vote_weight?: number;
  /**
   *
   * @type {boolean}
   * @memberof CommunityGetCommunity200ResponseCommunityStakesInner
   */
  stake_enabled?: boolean;
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200ResponseCommunityStakesInner
   */
  created_at?: string;
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200ResponseCommunityStakesInner
   */
  updated_at?: string;
  /**
   *
   * @type {Array<CommunityGetCommunity200ResponseCommunityStakesInnerStakeTransactionsInner>}
   * @memberof CommunityGetCommunity200ResponseCommunityStakesInner
   */
  StakeTransactions?: Array<CommunityGetCommunity200ResponseCommunityStakesInnerStakeTransactionsInner>;
}
/**
 *
 * @export
 * @interface CommunityGetCommunity200ResponseCommunityStakesInnerStakeTransactionsInner
 */
export interface CommunityGetCommunity200ResponseCommunityStakesInnerStakeTransactionsInner {
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200ResponseCommunityStakesInnerStakeTransactionsInner
   */
  transaction_hash: string;
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200ResponseCommunityStakesInnerStakeTransactionsInner
   */
  community_id: string;
  /**
   *
   * @type {number}
   * @memberof CommunityGetCommunity200ResponseCommunityStakesInnerStakeTransactionsInner
   */
  stake_id?: number;
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200ResponseCommunityStakesInnerStakeTransactionsInner
   */
  address: string;
  /**
   *
   * @type {number}
   * @memberof CommunityGetCommunity200ResponseCommunityStakesInnerStakeTransactionsInner
   */
  stake_amount: number;
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200ResponseCommunityStakesInnerStakeTransactionsInner
   */
  stake_price?: string;
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200ResponseCommunityStakesInnerStakeTransactionsInner
   */
  stake_direction: CommunityGetCommunity200ResponseCommunityStakesInnerStakeTransactionsInnerStakeDirectionEnum;
  /**
   *
   * @type {number}
   * @memberof CommunityGetCommunity200ResponseCommunityStakesInnerStakeTransactionsInner
   */
  timestamp: number;
}

export const CommunityGetCommunity200ResponseCommunityStakesInnerStakeTransactionsInnerStakeDirectionEnum =
  {
    Buy: 'buy',
    Sell: 'sell',
  } as const;

export type CommunityGetCommunity200ResponseCommunityStakesInnerStakeTransactionsInnerStakeDirectionEnum =
  typeof CommunityGetCommunity200ResponseCommunityStakesInnerStakeTransactionsInnerStakeDirectionEnum[keyof typeof CommunityGetCommunity200ResponseCommunityStakesInnerStakeTransactionsInnerStakeDirectionEnum];

/**
 *
 * @export
 * @interface CommunityGetCommunity200ResponseCommunityTagsInner
 */
export interface CommunityGetCommunity200ResponseCommunityTagsInner {
  /**
   *
   * @type {number}
   * @memberof CommunityGetCommunity200ResponseCommunityTagsInner
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200ResponseCommunityTagsInner
   */
  name: string;
}
/**
 * On-Chain Contest Manager
 * @export
 * @interface CommunityGetCommunity200ResponseContestManagersInner
 */
export interface CommunityGetCommunity200ResponseContestManagersInner {
  /**
   * On-Chain contest manager address
   * @type {string}
   * @memberof CommunityGetCommunity200ResponseContestManagersInner
   */
  contest_address: string;
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200ResponseContestManagersInner
   */
  community_id: string;
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200ResponseContestManagersInner
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200ResponseContestManagersInner
   */
  image_url?: string;
  /**
   * Provided by admin on creation when stake funds are not used
   * @type {string}
   * @memberof CommunityGetCommunity200ResponseContestManagersInner
   */
  funding_token_address?: string | null;
  /**
   * Percentage of pool used for prizes in recurring contests
   * @type {number}
   * @memberof CommunityGetCommunity200ResponseContestManagersInner
   */
  prize_percentage?: number | null;
  /**
   * Sorted array of percentages for prize, from first to last
   * @type {Array<number>}
   * @memberof CommunityGetCommunity200ResponseContestManagersInner
   */
  payout_structure: Array<number>;
  /**
   * Recurring contest interval, 0 when one-off
   * @type {number}
   * @memberof CommunityGetCommunity200ResponseContestManagersInner
   */
  interval: number;
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200ResponseContestManagersInner
   */
  ticker?: string;
  /**
   *
   * @type {number}
   * @memberof CommunityGetCommunity200ResponseContestManagersInner
   */
  decimals?: number;
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200ResponseContestManagersInner
   */
  created_at: string;
  /**
   * Flags when contest policy is cancelled by admin
   * @type {boolean}
   * @memberof CommunityGetCommunity200ResponseContestManagersInner
   */
  cancelled?: boolean | null;
  /**
   * Flags when the one-off contest has ended and rollover was completed
   * @type {boolean}
   * @memberof CommunityGetCommunity200ResponseContestManagersInner
   */
  ended?: boolean | null;
  /**
   *
   * @type {Array<CommunityGetCommunity200ResponseTopicsInner>}
   * @memberof CommunityGetCommunity200ResponseContestManagersInner
   */
  topics?: Array<CommunityGetCommunity200ResponseTopicsInner>;
  /**
   *
   * @type {Array<CommunityGetCommunity200ResponseContestManagersInnerContestsInner>}
   * @memberof CommunityGetCommunity200ResponseContestManagersInner
   */
  contests?: Array<CommunityGetCommunity200ResponseContestManagersInnerContestsInner>;
}
/**
 * On-Chain contest instance
 * @export
 * @interface CommunityGetCommunity200ResponseContestManagersInnerContestsInner
 */
export interface CommunityGetCommunity200ResponseContestManagersInnerContestsInner {
  /**
   * On-Chain contest manager address
   * @type {string}
   * @memberof CommunityGetCommunity200ResponseContestManagersInnerContestsInner
   */
  contest_address: string;
  /**
   * On-Chain contest id, 0 when one-off
   * @type {number}
   * @memberof CommunityGetCommunity200ResponseContestManagersInnerContestsInner
   */
  contest_id: number;
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200ResponseContestManagersInnerContestsInner
   */
  start_time: string;
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200ResponseContestManagersInnerContestsInner
   */
  end_time: string;
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200ResponseContestManagersInnerContestsInner
   */
  score_updated_at?: string | null;
  /**
   * Contest score, sorted from first to last
   * @type {Array<CommunityGetCommunity200ResponseContestManagersInnerContestsInnerScoreInner>}
   * @memberof CommunityGetCommunity200ResponseContestManagersInnerContestsInner
   */
  score?: Array<CommunityGetCommunity200ResponseContestManagersInnerContestsInnerScoreInner> | null;
  /**
   *
   * @type {Array<CommunityGetCommunity200ResponseContestManagersInnerContestsInnerActionsInner>}
   * @memberof CommunityGetCommunity200ResponseContestManagersInnerContestsInner
   */
  actions?: Array<CommunityGetCommunity200ResponseContestManagersInnerContestsInnerActionsInner> | null;
}
/**
 * On-Chain content related actions on contest instance
 * @export
 * @interface CommunityGetCommunity200ResponseContestManagersInnerContestsInnerActionsInner
 */
export interface CommunityGetCommunity200ResponseContestManagersInnerContestsInnerActionsInner {
  /**
   * On-Chain contest manager address
   * @type {string}
   * @memberof CommunityGetCommunity200ResponseContestManagersInnerContestsInnerActionsInner
   */
  contest_address: string;
  /**
   * On-Chain contest id, 0 when one-off
   * @type {number}
   * @memberof CommunityGetCommunity200ResponseContestManagersInnerContestsInnerActionsInner
   */
  contest_id: number;
  /**
   * On-Chain content id, 0 when adding
   * @type {number}
   * @memberof CommunityGetCommunity200ResponseContestManagersInnerContestsInnerActionsInner
   */
  content_id: number;
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200ResponseContestManagersInnerContestsInnerActionsInner
   */
  actor_address: string;
  /**
   * Type of content action
   * @type {string}
   * @memberof CommunityGetCommunity200ResponseContestManagersInnerContestsInnerActionsInner
   */
  action: CommunityGetCommunity200ResponseContestManagersInnerContestsInnerActionsInnerActionEnum;
  /**
   * Content url
   * @type {string}
   * @memberof CommunityGetCommunity200ResponseContestManagersInnerContestsInnerActionsInner
   */
  content_url?: string | null;
  /**
   * Thread id mapped from content url
   * @type {number}
   * @memberof CommunityGetCommunity200ResponseContestManagersInnerContestsInnerActionsInner
   */
  thread_id?: number | null;
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200ResponseContestManagersInnerContestsInnerActionsInner
   */
  thread_title?: string | null;
  /**
   * Voting power of address when action was recorded
   * @type {number}
   * @memberof CommunityGetCommunity200ResponseContestManagersInnerContestsInnerActionsInner
   */
  voting_power: number;
  /**
   * Date-time when action was recorded
   * @type {string}
   * @memberof CommunityGetCommunity200ResponseContestManagersInnerContestsInnerActionsInner
   */
  created_at: string;
}

export const CommunityGetCommunity200ResponseContestManagersInnerContestsInnerActionsInnerActionEnum =
  {
    Added: 'added',
    Upvoted: 'upvoted',
  } as const;

export type CommunityGetCommunity200ResponseContestManagersInnerContestsInnerActionsInnerActionEnum =
  typeof CommunityGetCommunity200ResponseContestManagersInnerContestsInnerActionsInnerActionEnum[keyof typeof CommunityGetCommunity200ResponseContestManagersInnerContestsInnerActionsInnerActionEnum];

/**
 *
 * @export
 * @interface CommunityGetCommunity200ResponseContestManagersInnerContestsInnerScoreInner
 */
export interface CommunityGetCommunity200ResponseContestManagersInnerContestsInnerScoreInner {
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200ResponseContestManagersInnerContestsInnerScoreInner
   */
  creator_address: string;
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200ResponseContestManagersInnerContestsInnerScoreInner
   */
  content_id: string;
  /**
   *
   * @type {number}
   * @memberof CommunityGetCommunity200ResponseContestManagersInnerContestsInnerScoreInner
   */
  votes: number;
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200ResponseContestManagersInnerContestsInnerScoreInner
   */
  prize: string;
  /**
   *
   * @type {number}
   * @memberof CommunityGetCommunity200ResponseContestManagersInnerContestsInnerScoreInner
   */
  tickerPrize?: number;
}
/**
 *
 * @export
 * @interface CommunityGetCommunity200ResponseGroupsInner
 */
export interface CommunityGetCommunity200ResponseGroupsInner {
  /**
   *
   * @type {number}
   * @memberof CommunityGetCommunity200ResponseGroupsInner
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200ResponseGroupsInner
   */
  community_id: string;
  /**
   *
   * @type {CommunityGetCommunity200ResponseGroupsInnerMetadata}
   * @memberof CommunityGetCommunity200ResponseGroupsInner
   */
  metadata: CommunityGetCommunity200ResponseGroupsInnerMetadata;
  /**
   *
   * @type {Array<CommunityGetCommunity200ResponseGroupsInnerRequirementsInner>}
   * @memberof CommunityGetCommunity200ResponseGroupsInner
   */
  requirements: Array<CommunityGetCommunity200ResponseGroupsInnerRequirementsInner>;
  /**
   *
   * @type {boolean}
   * @memberof CommunityGetCommunity200ResponseGroupsInner
   */
  is_system_managed?: boolean;
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200ResponseGroupsInner
   */
  created_at?: string;
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200ResponseGroupsInner
   */
  updated_at?: string;
}
/**
 *
 * @export
 * @interface CommunityGetCommunity200ResponseGroupsInnerMetadata
 */
export interface CommunityGetCommunity200ResponseGroupsInnerMetadata {
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200ResponseGroupsInnerMetadata
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200ResponseGroupsInnerMetadata
   */
  description: string;
  /**
   *
   * @type {number}
   * @memberof CommunityGetCommunity200ResponseGroupsInnerMetadata
   */
  required_requirements?: number;
  /**
   *
   * @type {number}
   * @memberof CommunityGetCommunity200ResponseGroupsInnerMetadata
   */
  membership_ttl?: number;
}
/**
 *
 * @export
 * @interface CommunityGetCommunity200ResponseGroupsInnerRequirementsInner
 */
export interface CommunityGetCommunity200ResponseGroupsInnerRequirementsInner {
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200ResponseGroupsInnerRequirementsInner
   */
  rule: CommunityGetCommunity200ResponseGroupsInnerRequirementsInnerRuleEnum;
  /**
   *
   * @type {CommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOf1Data}
   * @memberof CommunityGetCommunity200ResponseGroupsInnerRequirementsInner
   */
  data: CommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOf1Data;
}

export const CommunityGetCommunity200ResponseGroupsInnerRequirementsInnerRuleEnum =
  {
    Allow: 'allow',
  } as const;

export type CommunityGetCommunity200ResponseGroupsInnerRequirementsInnerRuleEnum =
  typeof CommunityGetCommunity200ResponseGroupsInnerRequirementsInnerRuleEnum[keyof typeof CommunityGetCommunity200ResponseGroupsInnerRequirementsInnerRuleEnum];

/**
 *
 * @export
 * @interface CommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOf
 */
export interface CommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOf {
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOf
   */
  rule: CommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfRuleEnum;
  /**
   *
   * @type {CommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfData}
   * @memberof CommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOf
   */
  data: CommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfData;
}

export const CommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfRuleEnum =
  {
    Threshold: 'threshold',
  } as const;

export type CommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfRuleEnum =
  typeof CommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfRuleEnum[keyof typeof CommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfRuleEnum];

/**
 *
 * @export
 * @interface CommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOf1
 */
export interface CommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOf1 {
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOf1
   */
  rule: CommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOf1RuleEnum;
  /**
   *
   * @type {CommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOf1Data}
   * @memberof CommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOf1
   */
  data: CommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOf1Data;
}

export const CommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOf1RuleEnum =
  {
    Allow: 'allow',
  } as const;

export type CommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOf1RuleEnum =
  typeof CommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOf1RuleEnum[keyof typeof CommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOf1RuleEnum];

/**
 *
 * @export
 * @interface CommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOf1Data
 */
export interface CommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOf1Data {
  /**
   *
   * @type {Array<string>}
   * @memberof CommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOf1Data
   */
  allow: Array<string>;
}
/**
 *
 * @export
 * @interface CommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfData
 */
export interface CommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfData {
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfData
   */
  threshold: string;
  /**
   *
   * @type {CommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSource}
   * @memberof CommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfData
   */
  source: CommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSource;
}
/**
 *
 * @export
 * @interface CommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSource
 */
export interface CommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSource {
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSource
   */
  source_type: CommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSourceSourceTypeEnum;
  /**
   *
   * @type {number}
   * @memberof CommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSource
   */
  evm_chain_id: number;
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSource
   */
  contract_address: string;
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSource
   */
  token_id?: string;
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSource
   */
  cosmos_chain_id: string;
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSource
   */
  token_symbol: string;
}

export const CommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSourceSourceTypeEnum =
  {
    Cw721: 'cw721',
    Cw20: 'cw20',
  } as const;

export type CommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSourceSourceTypeEnum =
  typeof CommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSourceSourceTypeEnum[keyof typeof CommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSourceSourceTypeEnum];

/**
 *
 * @export
 * @interface CommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSourceAnyOf
 */
export interface CommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSourceAnyOf {
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSourceAnyOf
   */
  source_type: CommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSourceAnyOfSourceTypeEnum;
  /**
   *
   * @type {number}
   * @memberof CommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSourceAnyOf
   */
  evm_chain_id: number;
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSourceAnyOf
   */
  contract_address: string;
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSourceAnyOf
   */
  token_id?: string;
}

export const CommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSourceAnyOfSourceTypeEnum =
  {
    Erc20: 'erc20',
    Erc721: 'erc721',
    Erc1155: 'erc1155',
    Spl: 'spl',
  } as const;

export type CommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSourceAnyOfSourceTypeEnum =
  typeof CommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSourceAnyOfSourceTypeEnum[keyof typeof CommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSourceAnyOfSourceTypeEnum];

/**
 *
 * @export
 * @interface CommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSourceAnyOf1
 */
export interface CommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSourceAnyOf1 {
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSourceAnyOf1
   */
  source_type: CommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSourceAnyOf1SourceTypeEnum;
  /**
   *
   * @type {number}
   * @memberof CommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSourceAnyOf1
   */
  evm_chain_id: number;
}

export const CommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSourceAnyOf1SourceTypeEnum =
  {
    EthNative: 'eth_native',
  } as const;

export type CommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSourceAnyOf1SourceTypeEnum =
  typeof CommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSourceAnyOf1SourceTypeEnum[keyof typeof CommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSourceAnyOf1SourceTypeEnum];

/**
 *
 * @export
 * @interface CommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSourceAnyOf2
 */
export interface CommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSourceAnyOf2 {
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSourceAnyOf2
   */
  source_type: CommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSourceAnyOf2SourceTypeEnum;
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSourceAnyOf2
   */
  cosmos_chain_id: string;
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSourceAnyOf2
   */
  token_symbol: string;
}

export const CommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSourceAnyOf2SourceTypeEnum =
  {
    CosmosNative: 'cosmos_native',
  } as const;

export type CommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSourceAnyOf2SourceTypeEnum =
  typeof CommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSourceAnyOf2SourceTypeEnum[keyof typeof CommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSourceAnyOf2SourceTypeEnum];

/**
 *
 * @export
 * @interface CommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSourceAnyOf3
 */
export interface CommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSourceAnyOf3 {
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSourceAnyOf3
   */
  source_type: CommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSourceAnyOf3SourceTypeEnum;
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSourceAnyOf3
   */
  cosmos_chain_id: string;
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSourceAnyOf3
   */
  contract_address: string;
}

export const CommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSourceAnyOf3SourceTypeEnum =
  {
    Cw721: 'cw721',
    Cw20: 'cw20',
  } as const;

export type CommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSourceAnyOf3SourceTypeEnum =
  typeof CommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSourceAnyOf3SourceTypeEnum[keyof typeof CommunityGetCommunity200ResponseGroupsInnerRequirementsInnerAnyOfDataSourceAnyOf3SourceTypeEnum];

/**
 *
 * @export
 * @interface CommunityGetCommunity200ResponseTopicsInner
 */
export interface CommunityGetCommunity200ResponseTopicsInner {
  /**
   *
   * @type {number}
   * @memberof CommunityGetCommunity200ResponseTopicsInner
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200ResponseTopicsInner
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200ResponseTopicsInner
   */
  community_id: string;
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200ResponseTopicsInner
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200ResponseTopicsInner
   */
  telegram?: string | null;
  /**
   *
   * @type {boolean}
   * @memberof CommunityGetCommunity200ResponseTopicsInner
   */
  featured_in_sidebar?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof CommunityGetCommunity200ResponseTopicsInner
   */
  featured_in_new_post?: boolean;
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200ResponseTopicsInner
   */
  default_offchain_template?: string | null;
  /**
   *
   * @type {number}
   * @memberof CommunityGetCommunity200ResponseTopicsInner
   */
  order?: number | null;
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200ResponseTopicsInner
   */
  channel_id?: string | null;
  /**
   *
   * @type {Array<number>}
   * @memberof CommunityGetCommunity200ResponseTopicsInner
   */
  group_ids?: Array<number>;
  /**
   *
   * @type {string}
   * @memberof CommunityGetCommunity200ResponseTopicsInner
   */
  default_offchain_template_backup?: string | null;
}
/**
 *
 * @export
 * @interface CommunityGetMembers200Response
 */
export interface CommunityGetMembers200Response {
  /**
   *
   * @type {number}
   * @memberof CommunityGetMembers200Response
   */
  limit: number;
  /**
   *
   * @type {number}
   * @memberof CommunityGetMembers200Response
   */
  page: number;
  /**
   *
   * @type {number}
   * @memberof CommunityGetMembers200Response
   */
  totalPages: number;
  /**
   *
   * @type {number}
   * @memberof CommunityGetMembers200Response
   */
  totalResults: number;
  /**
   *
   * @type {Array<CommunityGetMembers200ResponseResultsInner>}
   * @memberof CommunityGetMembers200Response
   */
  results: Array<CommunityGetMembers200ResponseResultsInner>;
}
/**
 *
 * @export
 * @interface CommunityGetMembers200ResponseResultsInner
 */
export interface CommunityGetMembers200ResponseResultsInner {
  /**
   *
   * @type {number}
   * @memberof CommunityGetMembers200ResponseResultsInner
   */
  user_id: number;
  /**
   *
   * @type {string}
   * @memberof CommunityGetMembers200ResponseResultsInner
   */
  profile_name?: string | null;
  /**
   *
   * @type {string}
   * @memberof CommunityGetMembers200ResponseResultsInner
   */
  avatar_url?: string | null;
  /**
   *
   * @type {Array<CommunityGetMembers200ResponseResultsInnerAddressesInner>}
   * @memberof CommunityGetMembers200ResponseResultsInner
   */
  addresses: Array<CommunityGetMembers200ResponseResultsInnerAddressesInner>;
  /**
   *
   * @type {Array<number>}
   * @memberof CommunityGetMembers200ResponseResultsInner
   */
  group_ids: Array<number>;
  /**
   * string or date
   * @type {any}
   * @memberof CommunityGetMembers200ResponseResultsInner
   */
  last_active?: any | null;
}
/**
 *
 * @export
 * @interface CommunityGetMembers200ResponseResultsInnerAddressesInner
 */
export interface CommunityGetMembers200ResponseResultsInnerAddressesInner {
  /**
   *
   * @type {number}
   * @memberof CommunityGetMembers200ResponseResultsInnerAddressesInner
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof CommunityGetMembers200ResponseResultsInnerAddressesInner
   */
  community_id: string;
  /**
   *
   * @type {string}
   * @memberof CommunityGetMembers200ResponseResultsInnerAddressesInner
   */
  address: string;
  /**
   *
   * @type {number}
   * @memberof CommunityGetMembers200ResponseResultsInnerAddressesInner
   */
  stake_balance?: number | null;
  /**
   *
   * @type {string}
   * @memberof CommunityGetMembers200ResponseResultsInnerAddressesInner
   */
  role: string;
}
/**
 *
 * @export
 * @interface CommunityGetMembersMembershipsParameter
 */
export interface CommunityGetMembersMembershipsParameter {}
/**
 *
 * @export
 * @interface CommunityGetStake200Response
 */
export interface CommunityGetStake200Response {
  /**
   *
   * @type {number}
   * @memberof CommunityGetStake200Response
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof CommunityGetStake200Response
   */
  community_id: string;
  /**
   *
   * @type {number}
   * @memberof CommunityGetStake200Response
   */
  stake_id?: number;
  /**
   *
   * @type {string}
   * @memberof CommunityGetStake200Response
   */
  stake_token?: string;
  /**
   *
   * @type {number}
   * @memberof CommunityGetStake200Response
   */
  vote_weight?: number;
  /**
   *
   * @type {boolean}
   * @memberof CommunityGetStake200Response
   */
  stake_enabled?: boolean;
  /**
   *
   * @type {string}
   * @memberof CommunityGetStake200Response
   */
  created_at?: string;
  /**
   *
   * @type {string}
   * @memberof CommunityGetStake200Response
   */
  updated_at?: string;
  /**
   *
   * @type {Array<CommunityGetCommunity200ResponseCommunityStakesInnerStakeTransactionsInner>}
   * @memberof CommunityGetStake200Response
   */
  StakeTransactions?: Array<CommunityGetCommunity200ResponseCommunityStakesInnerStakeTransactionsInner>;
}
/**
 *
 * @export
 * @interface CommunityGetStakeHistoricalPrice200ResponseInner
 */
export interface CommunityGetStakeHistoricalPrice200ResponseInner {
  /**
   *
   * @type {string}
   * @memberof CommunityGetStakeHistoricalPrice200ResponseInner
   */
  community_id: string;
  /**
   *
   * @type {string}
   * @memberof CommunityGetStakeHistoricalPrice200ResponseInner
   */
  old_price?: string | null;
}
/**
 *
 * @export
 * @interface CommunityGetStakeTransaction200ResponseInner
 */
export interface CommunityGetStakeTransaction200ResponseInner {
  /**
   *
   * @type {string}
   * @memberof CommunityGetStakeTransaction200ResponseInner
   */
  transaction_hash: string;
  /**
   *
   * @type {string}
   * @memberof CommunityGetStakeTransaction200ResponseInner
   */
  address: string;
  /**
   *
   * @type {string}
   * @memberof CommunityGetStakeTransaction200ResponseInner
   */
  stake_price: string;
  /**
   *
   * @type {number}
   * @memberof CommunityGetStakeTransaction200ResponseInner
   */
  stake_amount: number;
  /**
   *
   * @type {number}
   * @memberof CommunityGetStakeTransaction200ResponseInner
   */
  vote_weight: number;
  /**
   *
   * @type {number}
   * @memberof CommunityGetStakeTransaction200ResponseInner
   */
  timestamp: number;
  /**
   *
   * @type {string}
   * @memberof CommunityGetStakeTransaction200ResponseInner
   */
  stake_direction: string;
  /**
   *
   * @type {CommunityGetStakeTransaction200ResponseInnerCommunity}
   * @memberof CommunityGetStakeTransaction200ResponseInner
   */
  community: CommunityGetStakeTransaction200ResponseInnerCommunity;
}
/**
 *
 * @export
 * @interface CommunityGetStakeTransaction200ResponseInnerCommunity
 */
export interface CommunityGetStakeTransaction200ResponseInnerCommunity {
  /**
   *
   * @type {string}
   * @memberof CommunityGetStakeTransaction200ResponseInnerCommunity
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof CommunityGetStakeTransaction200ResponseInnerCommunity
   */
  default_symbol?: string | null;
  /**
   *
   * @type {string}
   * @memberof CommunityGetStakeTransaction200ResponseInnerCommunity
   */
  icon_url?: string | null;
  /**
   *
   * @type {string}
   * @memberof CommunityGetStakeTransaction200ResponseInnerCommunity
   */
  name: string;
  /**
   *
   * @type {number}
   * @memberof CommunityGetStakeTransaction200ResponseInnerCommunity
   */
  chain_node_id?: number | null;
}
/**
 *
 * @export
 * @interface CommunitySetStake200Response
 */
export interface CommunitySetStake200Response {
  /**
   *
   * @type {string}
   * @memberof CommunitySetStake200Response
   */
  name: string;
  /**
   *
   * @type {number}
   * @memberof CommunitySetStake200Response
   */
  chain_node_id: number;
  /**
   *
   * @type {string}
   * @memberof CommunitySetStake200Response
   */
  default_symbol?: string;
  /**
   *
   * @type {string}
   * @memberof CommunitySetStake200Response
   */
  network?: CommunitySetStake200ResponseNetworkEnum;
  /**
   *
   * @type {string}
   * @memberof CommunitySetStake200Response
   */
  base: CommunitySetStake200ResponseBaseEnum;
  /**
   *
   * @type {string}
   * @memberof CommunitySetStake200Response
   */
  icon_url?: string | null;
  /**
   *
   * @type {boolean}
   * @memberof CommunitySetStake200Response
   */
  active: boolean;
  /**
   *
   * @type {string}
   * @memberof CommunitySetStake200Response
   */
  type?: CommunitySetStake200ResponseTypeEnum;
  /**
   *
   * @type {string}
   * @memberof CommunitySetStake200Response
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof CommunitySetStake200Response
   */
  description?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof CommunitySetStake200Response
   */
  social_links?: Array<string>;
  /**
   *
   * @type {number}
   * @memberof CommunitySetStake200Response
   */
  ss58_prefix?: number;
  /**
   *
   * @type {boolean}
   * @memberof CommunitySetStake200Response
   */
  stages_enabled?: boolean;
  /**
   *
   * @type {Array<string>}
   * @memberof CommunitySetStake200Response
   */
  custom_stages?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof CommunitySetStake200Response
   */
  custom_domain?: string;
  /**
   *
   * @type {string}
   * @memberof CommunitySetStake200Response
   */
  block_explorer_ids?: string;
  /**
   *
   * @type {boolean}
   * @memberof CommunitySetStake200Response
   */
  collapsed_on_homepage?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof CommunitySetStake200Response
   */
  has_chain_events_listener?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof CommunitySetStake200Response
   */
  default_summary_view?: boolean;
  /**
   *
   * @type {string}
   * @memberof CommunitySetStake200Response
   */
  default_page?: CommunitySetStake200ResponseDefaultPageEnum;
  /**
   *
   * @type {string}
   * @memberof CommunitySetStake200Response
   */
  has_homepage?: CommunitySetStake200ResponseHasHomepageEnum | null;
  /**
   *
   * @type {string}
   * @memberof CommunitySetStake200Response
   */
  terms?: string;
  /**
   *
   * @type {boolean}
   * @memberof CommunitySetStake200Response
   */
  admin_only_polling?: boolean;
  /**
   *
   * @type {string}
   * @memberof CommunitySetStake200Response
   */
  bech32_prefix?: string;
  /**
   *
   * @type {boolean}
   * @memberof CommunitySetStake200Response
   */
  hide_projects?: boolean;
  /**
   *
   * @type {string}
   * @memberof CommunitySetStake200Response
   */
  token_name?: string;
  /**
   *
   * @type {boolean}
   * @memberof CommunitySetStake200Response
   */
  ce_verbose?: boolean;
  /**
   *
   * @type {number}
   * @memberof CommunitySetStake200Response
   */
  discord_config_id?: number | null;
  /**
   *
   * @type {any}
   * @memberof CommunitySetStake200Response
   */
  category?: any;
  /**
   *
   * @type {boolean}
   * @memberof CommunitySetStake200Response
   */
  discord_bot_webhooks_enabled?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof CommunitySetStake200Response
   */
  directory_page_enabled?: boolean;
  /**
   *
   * @type {number}
   * @memberof CommunitySetStake200Response
   */
  directory_page_chain_node_id?: number;
  /**
   *
   * @type {string}
   * @memberof CommunitySetStake200Response
   */
  namespace?: string;
  /**
   *
   * @type {string}
   * @memberof CommunitySetStake200Response
   */
  namespace_address?: string;
  /**
   *
   * @type {string}
   * @memberof CommunitySetStake200Response
   */
  redirect?: string;
  /**
   *
   * @type {string}
   * @memberof CommunitySetStake200Response
   */
  created_at?: string;
  /**
   *
   * @type {string}
   * @memberof CommunitySetStake200Response
   */
  updated_at?: string;
  /**
   *
   * @type {Array<CommunityGetCommunity200ResponseAddressesInner>}
   * @memberof CommunitySetStake200Response
   */
  Addresses?: Array<CommunityGetCommunity200ResponseAddressesInner>;
  /**
   *
   * @type {Array<CommunityGetCommunity200ResponseCommunityStakesInner>}
   * @memberof CommunitySetStake200Response
   */
  CommunityStakes?: Array<CommunityGetCommunity200ResponseCommunityStakesInner>;
  /**
   *
   * @type {Array<CommunityGetCommunity200ResponseCommunityTagsInner>}
   * @memberof CommunitySetStake200Response
   */
  CommunityTags?: Array<CommunityGetCommunity200ResponseCommunityTagsInner>;
  /**
   *
   * @type {CommunityGetCommunity200ResponseChainNode}
   * @memberof CommunitySetStake200Response
   */
  ChainNode?: CommunityGetCommunity200ResponseChainNode;
  /**
   *
   * @type {Array<CommunityGetCommunity200ResponseTopicsInner>}
   * @memberof CommunitySetStake200Response
   */
  topics?: Array<CommunityGetCommunity200ResponseTopicsInner>;
  /**
   *
   * @type {Array<CommunityGetCommunity200ResponseGroupsInner>}
   * @memberof CommunitySetStake200Response
   */
  groups?: Array<CommunityGetCommunity200ResponseGroupsInner>;
  /**
   *
   * @type {Array<CommunityGetCommunity200ResponseContestManagersInner>}
   * @memberof CommunitySetStake200Response
   */
  contest_managers?: Array<CommunityGetCommunity200ResponseContestManagersInner>;
  /**
   *
   * @type {Array<string>}
   * @memberof CommunitySetStake200Response
   */
  snapshot_spaces?: Array<string>;
  /**
   *
   * @type {boolean}
   * @memberof CommunitySetStake200Response
   */
  include_in_digest_email?: boolean | null;
}

export const CommunitySetStake200ResponseNetworkEnum = {
  Edgeware: 'edgeware',
  EdgewareTestnet: 'edgeware-testnet',
  Kusama: 'kusama',
  Kulupu: 'kulupu',
  Polkadot: 'polkadot',
  Plasm: 'plasm',
  Stafi: 'stafi',
  Darwinia: 'darwinia',
  Phala: 'phala',
  Centrifuge: 'centrifuge',
  Straightedge: 'straightedge',
  Osmosis: 'osmosis',
  Injective: 'injective',
  InjectiveTestnet: 'injective-testnet',
  Terra: 'terra',
  Ethereum: 'ethereum',
  Near: 'near',
  NearTestnet: 'near-testnet',
  Compound: 'compound',
  Aave: 'aave',
  AaveLocal: 'aave-local',
  Dydx: 'dydx',
  Metacartel: 'metacartel',
  Alex: 'alex',
  Erc20: 'erc20',
  Erc721: 'erc721',
  Erc1155: 'erc1155',
  Cw20: 'cw20',
  Cw721: 'cw721',
  Clover: 'clover',
  Hydradx: 'hydradx',
  Crust: 'crust',
  Sputnik: 'sputnik',
  SolanaDevnet: 'solana-devnet',
  SolanaTestnet: 'solana-testnet',
  Solana: 'solana',
  Spl: 'spl',
  Evmos: 'evmos',
  Kava: 'kava',
  Kyve: 'kyve',
  Stargaze: 'stargaze',
  Cosmos: 'cosmos',
} as const;

export type CommunitySetStake200ResponseNetworkEnum =
  typeof CommunitySetStake200ResponseNetworkEnum[keyof typeof CommunitySetStake200ResponseNetworkEnum];
export const CommunitySetStake200ResponseBaseEnum = {
  Cosmos: 'cosmos',
  Substrate: 'substrate',
  Ethereum: 'ethereum',
  Near: 'near',
  Solana: 'solana',
} as const;

export type CommunitySetStake200ResponseBaseEnum =
  typeof CommunitySetStake200ResponseBaseEnum[keyof typeof CommunitySetStake200ResponseBaseEnum];
export const CommunitySetStake200ResponseTypeEnum = {
  Chain: 'chain',
  Dao: 'dao',
  Token: 'token',
  Offchain: 'offchain',
} as const;

export type CommunitySetStake200ResponseTypeEnum =
  typeof CommunitySetStake200ResponseTypeEnum[keyof typeof CommunitySetStake200ResponseTypeEnum];
export const CommunitySetStake200ResponseDefaultPageEnum = {
  AllDiscussionsView: 'default_all_discussions_view',
  SummaryView: 'default_summary_view',
} as const;

export type CommunitySetStake200ResponseDefaultPageEnum =
  typeof CommunitySetStake200ResponseDefaultPageEnum[keyof typeof CommunitySetStake200ResponseDefaultPageEnum];
export const CommunitySetStake200ResponseHasHomepageEnum = {
  True: 'true',
  False: 'false',
} as const;

export type CommunitySetStake200ResponseHasHomepageEnum =
  typeof CommunitySetStake200ResponseHasHomepageEnum[keyof typeof CommunitySetStake200ResponseHasHomepageEnum];

/**
 *
 * @export
 * @interface CommunitySetStakeRequest
 */
export interface CommunitySetStakeRequest {
  /**
   *
   * @type {number}
   * @memberof CommunitySetStakeRequest
   */
  stake_id: number;
  /**
   *
   * @type {string}
   * @memberof CommunitySetStakeRequest
   */
  stake_token?: string;
  /**
   *
   * @type {number}
   * @memberof CommunitySetStakeRequest
   */
  vote_weight?: number;
  /**
   *
   * @type {boolean}
   * @memberof CommunitySetStakeRequest
   */
  stake_enabled?: boolean;
}
/**
 *
 * @export
 * @interface ContestCreateContestMetadata200Response
 */
export interface ContestCreateContestMetadata200Response {
  /**
   *
   * @type {Array<CommunityGetCommunity200ResponseContestManagersInner>}
   * @memberof ContestCreateContestMetadata200Response
   */
  contest_managers: Array<CommunityGetCommunity200ResponseContestManagersInner>;
}
/**
 *
 * @export
 * @interface ContestCreateContestMetadataRequest
 */
export interface ContestCreateContestMetadataRequest {
  /**
   * On-Chain contest manager address
   * @type {string}
   * @memberof ContestCreateContestMetadataRequest
   */
  contest_address: string;
  /**
   *
   * @type {string}
   * @memberof ContestCreateContestMetadataRequest
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof ContestCreateContestMetadataRequest
   */
  image_url?: string;
  /**
   * Provided by admin on creation when stake funds are not used
   * @type {string}
   * @memberof ContestCreateContestMetadataRequest
   */
  funding_token_address?: string;
  /**
   * Percentage of pool used for prizes in recurring contests
   * @type {number}
   * @memberof ContestCreateContestMetadataRequest
   */
  prize_percentage?: number;
  /**
   * Sorted array of percentages for prize, from first to last
   * @type {Array<number>}
   * @memberof ContestCreateContestMetadataRequest
   */
  payout_structure: Array<number>;
  /**
   * Recurring contest interval in seconds, 0 when one-off
   * @type {number}
   * @memberof ContestCreateContestMetadataRequest
   */
  interval: number;
  /**
   *
   * @type {string}
   * @memberof ContestCreateContestMetadataRequest
   */
  ticker?: string;
  /**
   *
   * @type {number}
   * @memberof ContestCreateContestMetadataRequest
   */
  decimals?: number;
  /**
   *
   * @type {Array<number>}
   * @memberof ContestCreateContestMetadataRequest
   */
  topic_ids?: Array<number>;
}
/**
 * On-Chain Contest Manager
 * @export
 * @interface ContestGetAllContests200ResponseInner
 */
export interface ContestGetAllContests200ResponseInner {
  /**
   * On-Chain contest manager address
   * @type {string}
   * @memberof ContestGetAllContests200ResponseInner
   */
  contest_address: string;
  /**
   *
   * @type {string}
   * @memberof ContestGetAllContests200ResponseInner
   */
  community_id: string;
  /**
   *
   * @type {string}
   * @memberof ContestGetAllContests200ResponseInner
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof ContestGetAllContests200ResponseInner
   */
  image_url?: string;
  /**
   * Provided by admin on creation when stake funds are not used
   * @type {string}
   * @memberof ContestGetAllContests200ResponseInner
   */
  funding_token_address?: string | null;
  /**
   * Percentage of pool used for prizes in recurring contests
   * @type {number}
   * @memberof ContestGetAllContests200ResponseInner
   */
  prize_percentage?: number | null;
  /**
   * Sorted array of percentages for prize, from first to last
   * @type {Array<number>}
   * @memberof ContestGetAllContests200ResponseInner
   */
  payout_structure: Array<number>;
  /**
   * Recurring contest interval, 0 when one-off
   * @type {number}
   * @memberof ContestGetAllContests200ResponseInner
   */
  interval: number;
  /**
   *
   * @type {string}
   * @memberof ContestGetAllContests200ResponseInner
   */
  ticker?: string;
  /**
   *
   * @type {number}
   * @memberof ContestGetAllContests200ResponseInner
   */
  decimals?: number;
  /**
   *
   * @type {string}
   * @memberof ContestGetAllContests200ResponseInner
   */
  created_at: string;
  /**
   * Flags when contest policy is cancelled by admin
   * @type {boolean}
   * @memberof ContestGetAllContests200ResponseInner
   */
  cancelled?: boolean | null;
  /**
   * Flags when the one-off contest has ended and rollover was completed
   * @type {boolean}
   * @memberof ContestGetAllContests200ResponseInner
   */
  ended?: boolean | null;
  /**
   *
   * @type {Array<ContestGetAllContests200ResponseInnerTopicsInner>}
   * @memberof ContestGetAllContests200ResponseInner
   */
  topics: Array<ContestGetAllContests200ResponseInnerTopicsInner>;
  /**
   *
   * @type {Array<ContestGetAllContests200ResponseInnerContestsInner>}
   * @memberof ContestGetAllContests200ResponseInner
   */
  contests: Array<ContestGetAllContests200ResponseInnerContestsInner>;
}
/**
 * On-Chain contest instance
 * @export
 * @interface ContestGetAllContests200ResponseInnerContestsInner
 */
export interface ContestGetAllContests200ResponseInnerContestsInner {
  /**
   * On-Chain contest id, 0 when one-off
   * @type {number}
   * @memberof ContestGetAllContests200ResponseInnerContestsInner
   */
  contest_id: number;
  /**
   *
   * @type {string}
   * @memberof ContestGetAllContests200ResponseInnerContestsInner
   */
  start_time: string;
  /**
   *
   * @type {string}
   * @memberof ContestGetAllContests200ResponseInnerContestsInner
   */
  end_time: string;
  /**
   *
   * @type {string}
   * @memberof ContestGetAllContests200ResponseInnerContestsInner
   */
  score_updated_at?: string | null;
  /**
   * Contest score, sorted from first to last
   * @type {Array<CommunityGetCommunity200ResponseContestManagersInnerContestsInnerScoreInner>}
   * @memberof ContestGetAllContests200ResponseInnerContestsInner
   */
  score?: Array<CommunityGetCommunity200ResponseContestManagersInnerContestsInnerScoreInner> | null;
  /**
   *
   * @type {Array<CommunityGetCommunity200ResponseContestManagersInnerContestsInnerActionsInner>}
   * @memberof ContestGetAllContests200ResponseInnerContestsInner
   */
  actions?: Array<CommunityGetCommunity200ResponseContestManagersInnerContestsInnerActionsInner> | null;
}
/**
 *
 * @export
 * @interface ContestGetAllContests200ResponseInnerTopicsInner
 */
export interface ContestGetAllContests200ResponseInnerTopicsInner {
  /**
   *
   * @type {number}
   * @memberof ContestGetAllContests200ResponseInnerTopicsInner
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof ContestGetAllContests200ResponseInnerTopicsInner
   */
  name: string;
}
/**
 *
 * @export
 * @interface ContestGetContestLog200ResponseInner
 */
export interface ContestGetContestLog200ResponseInner {
  /**
   *
   * @type {string}
   * @memberof ContestGetContestLog200ResponseInner
   */
  event_name: string;
  /**
   *
   * @type {object}
   * @memberof ContestGetContestLog200ResponseInner
   */
  event_payload: object;
  /**
   *
   * @type {string}
   * @memberof ContestGetContestLog200ResponseInner
   */
  contest_address: string;
  /**
   *
   * @type {number}
   * @memberof ContestGetContestLog200ResponseInner
   */
  contest_id: number;
  /**
   *
   * @type {string}
   * @memberof ContestGetContestLog200ResponseInner
   */
  action?: string | null;
  /**
   *
   * @type {string}
   * @memberof ContestGetContestLog200ResponseInner
   */
  actor_address?: string | null;
  /**
   *
   * @type {number}
   * @memberof ContestGetContestLog200ResponseInner
   */
  voting_power?: number | null;
  /**
   *
   * @type {number}
   * @memberof ContestGetContestLog200ResponseInner
   */
  thread_id?: number | null;
  /**
   *
   * @type {string}
   * @memberof ContestGetContestLog200ResponseInner
   */
  thread_title?: string | null;
  /**
   *
   * @type {string}
   * @memberof ContestGetContestLog200ResponseInner
   */
  created_at: string;
}
/**
 *
 * @export
 * @interface ContestUpdateContestMetadataRequest
 */
export interface ContestUpdateContestMetadataRequest {
  /**
   * On-Chain contest manager address
   * @type {string}
   * @memberof ContestUpdateContestMetadataRequest
   */
  contest_address: string;
  /**
   *
   * @type {string}
   * @memberof ContestUpdateContestMetadataRequest
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof ContestUpdateContestMetadataRequest
   */
  image_url?: string;
  /**
   *
   * @type {Array<number>}
   * @memberof ContestUpdateContestMetadataRequest
   */
  topic_ids?: Array<number>;
}
/**
 *
 * @export
 * @interface FeedGetChainActivity200ResponseInner
 */
export interface FeedGetChainActivity200ResponseInner {
  /**
   *
   * @type {string}
   * @memberof FeedGetChainActivity200ResponseInner
   */
  community_id: string;
  /**
   *
   * @type {string}
   * @memberof FeedGetChainActivity200ResponseInner
   */
  network: string;
  /**
   *
   * @type {number}
   * @memberof FeedGetChainActivity200ResponseInner
   */
  block_number: number;
  /**
   *
   * @type {FeedGetChainActivity200ResponseInnerEventData}
   * @memberof FeedGetChainActivity200ResponseInner
   */
  event_data: FeedGetChainActivity200ResponseInnerEventData;
}
/**
 *
 * @export
 * @interface FeedGetChainActivity200ResponseInnerEventData
 */
export interface FeedGetChainActivity200ResponseInnerEventData {
  /**
   *
   * @type {string}
   * @memberof FeedGetChainActivity200ResponseInnerEventData
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof FeedGetChainActivity200ResponseInnerEventData
   */
  kind: string;
}
/**
 *
 * @export
 * @interface FeedGetUserActivity200ResponseInner
 */
export interface FeedGetUserActivity200ResponseInner {
  /**
   *
   * @type {number}
   * @memberof FeedGetUserActivity200ResponseInner
   */
  thread_id: number;
  /**
   *
   * @type {string}
   * @memberof FeedGetUserActivity200ResponseInner
   */
  last_activity?: string;
  /**
   *
   * @type {string}
   * @memberof FeedGetUserActivity200ResponseInner
   */
  notification_data: string;
  /**
   *
   * @type {string}
   * @memberof FeedGetUserActivity200ResponseInner
   */
  category_id: string;
  /**
   *
   * @type {number}
   * @memberof FeedGetUserActivity200ResponseInner
   */
  comment_count: number;
  /**
   *
   * @type {Array<FeedGetUserActivity200ResponseInnerCommentersInner>}
   * @memberof FeedGetUserActivity200ResponseInner
   */
  commenters: Array<FeedGetUserActivity200ResponseInnerCommentersInner>;
}
/**
 *
 * @export
 * @interface FeedGetUserActivity200ResponseInnerCommentersInner
 */
export interface FeedGetUserActivity200ResponseInnerCommentersInner {
  /**
   *
   * @type {Array<ThreadGetBulkThreads200ResponseThreadsInnerAddress>}
   * @memberof FeedGetUserActivity200ResponseInnerCommentersInner
   */
  Addresses: Array<ThreadGetBulkThreads200ResponseThreadsInnerAddress>;
}
/**
 *
 * @export
 * @interface IntegrationsAnalyticsRequest
 */
export interface IntegrationsAnalyticsRequest {
  /**
   *
   * @type {IntegrationsAnalyticsRequestGroupCreated}
   * @memberof IntegrationsAnalyticsRequest
   */
  GroupCreated: IntegrationsAnalyticsRequestGroupCreated;
  /**
   *
   * @type {IntegrationsAnalyticsRequestThreadCreated}
   * @memberof IntegrationsAnalyticsRequest
   */
  ThreadCreated: IntegrationsAnalyticsRequestThreadCreated;
  /**
   *
   * @type {IntegrationsAnalyticsRequestCommentCreated}
   * @memberof IntegrationsAnalyticsRequest
   */
  CommentCreated: IntegrationsAnalyticsRequestCommentCreated;
}
/**
 *
 * @export
 * @interface IntegrationsAnalyticsRequestCommentCreated
 */
export interface IntegrationsAnalyticsRequestCommentCreated {
  /**
   *
   * @type {number}
   * @memberof IntegrationsAnalyticsRequestCommentCreated
   */
  thread_id: number;
  /**
   *
   * @type {number}
   * @memberof IntegrationsAnalyticsRequestCommentCreated
   */
  address_id: number;
  /**
   *
   * @type {string}
   * @memberof IntegrationsAnalyticsRequestCommentCreated
   */
  text: string;
  /**
   *
   * @type {string}
   * @memberof IntegrationsAnalyticsRequestCommentCreated
   */
  plaintext: string;
  /**
   *
   * @type {number}
   * @memberof IntegrationsAnalyticsRequestCommentCreated
   */
  id?: number | null;
  /**
   *
   * @type {string}
   * @memberof IntegrationsAnalyticsRequestCommentCreated
   */
  community_id: string;
  /**
   *
   * @type {string}
   * @memberof IntegrationsAnalyticsRequestCommentCreated
   */
  parent_id?: string | null;
  /**
   *
   * @type {Array<string>}
   * @memberof IntegrationsAnalyticsRequestCommentCreated
   */
  version_history?: Array<string>;
  /**
   *
   * @type {boolean}
   * @memberof IntegrationsAnalyticsRequestCommentCreated
   */
  version_history_updated?: boolean;
  /**
   *
   * @type {string}
   * @memberof IntegrationsAnalyticsRequestCommentCreated
   */
  canvas_signed_data: string;
  /**
   *
   * @type {string}
   * @memberof IntegrationsAnalyticsRequestCommentCreated
   */
  canvas_hash: string;
  /**
   *
   * @type {string}
   * @memberof IntegrationsAnalyticsRequestCommentCreated
   */
  created_by?: string | null;
  /**
   *
   * @type {string}
   * @memberof IntegrationsAnalyticsRequestCommentCreated
   */
  created_at?: string | null;
  /**
   *
   * @type {string}
   * @memberof IntegrationsAnalyticsRequestCommentCreated
   */
  updated_at?: string | null;
  /**
   *
   * @type {string}
   * @memberof IntegrationsAnalyticsRequestCommentCreated
   */
  deleted_at?: string | null;
  /**
   *
   * @type {string}
   * @memberof IntegrationsAnalyticsRequestCommentCreated
   */
  marked_as_spam_at?: string | null;
  /**
   *
   * @type {ThreadGetBulkThreads200ResponseThreadsInnerDiscordMeta}
   * @memberof IntegrationsAnalyticsRequestCommentCreated
   */
  discord_meta?: ThreadGetBulkThreads200ResponseThreadsInnerDiscordMeta | null;
  /**
   *
   * @type {number}
   * @memberof IntegrationsAnalyticsRequestCommentCreated
   */
  reaction_count: number;
  /**
   *
   * @type {number}
   * @memberof IntegrationsAnalyticsRequestCommentCreated
   */
  reaction_weights_sum?: number;
  /**
   *
   * @type {IntegrationsAnalyticsRequestThreadCreatedAddress}
   * @memberof IntegrationsAnalyticsRequestCommentCreated
   */
  Address?: IntegrationsAnalyticsRequestThreadCreatedAddress | null;
}
/**
 *
 * @export
 * @interface IntegrationsAnalyticsRequestGroupCreated
 */
export interface IntegrationsAnalyticsRequestGroupCreated {
  /**
   *
   * @type {string}
   * @memberof IntegrationsAnalyticsRequestGroupCreated
   */
  groupId: string;
  /**
   *
   * @type {string}
   * @memberof IntegrationsAnalyticsRequestGroupCreated
   */
  userId: string;
}
/**
 *
 * @export
 * @interface IntegrationsAnalyticsRequestThreadCreated
 */
export interface IntegrationsAnalyticsRequestThreadCreated {
  /**
   *
   * @type {IntegrationsAnalyticsRequestThreadCreatedAddress}
   * @memberof IntegrationsAnalyticsRequestThreadCreated
   */
  Address?: IntegrationsAnalyticsRequestThreadCreatedAddress | null;
  /**
   *
   * @type {number}
   * @memberof IntegrationsAnalyticsRequestThreadCreated
   */
  address_id: number;
  /**
   *
   * @type {string}
   * @memberof IntegrationsAnalyticsRequestThreadCreated
   */
  title: string;
  /**
   *
   * @type {string}
   * @memberof IntegrationsAnalyticsRequestThreadCreated
   */
  kind: string;
  /**
   *
   * @type {string}
   * @memberof IntegrationsAnalyticsRequestThreadCreated
   */
  stage: string;
  /**
   *
   * @type {number}
   * @memberof IntegrationsAnalyticsRequestThreadCreated
   */
  id?: number | null;
  /**
   *
   * @type {string}
   * @memberof IntegrationsAnalyticsRequestThreadCreated
   */
  body?: string | null;
  /**
   *
   * @type {string}
   * @memberof IntegrationsAnalyticsRequestThreadCreated
   */
  plaintext?: string | null;
  /**
   *
   * @type {string}
   * @memberof IntegrationsAnalyticsRequestThreadCreated
   */
  url?: string | null;
  /**
   *
   * @type {number}
   * @memberof IntegrationsAnalyticsRequestThreadCreated
   */
  topic_id?: number | null;
  /**
   *
   * @type {boolean}
   * @memberof IntegrationsAnalyticsRequestThreadCreated
   */
  pinned?: boolean | null;
  /**
   *
   * @type {string}
   * @memberof IntegrationsAnalyticsRequestThreadCreated
   */
  community_id: string;
  /**
   *
   * @type {number}
   * @memberof IntegrationsAnalyticsRequestThreadCreated
   */
  view_count: number;
  /**
   *
   * @type {Array<ThreadGetBulkThreads200ResponseThreadsInnerLinksInner>}
   * @memberof IntegrationsAnalyticsRequestThreadCreated
   */
  links?: Array<ThreadGetBulkThreads200ResponseThreadsInnerLinksInner> | null;
  /**
   *
   * @type {boolean}
   * @memberof IntegrationsAnalyticsRequestThreadCreated
   */
  read_only?: boolean | null;
  /**
   *
   * @type {Array<string>}
   * @memberof IntegrationsAnalyticsRequestThreadCreated
   */
  version_history?: Array<string> | null;
  /**
   *
   * @type {boolean}
   * @memberof IntegrationsAnalyticsRequestThreadCreated
   */
  has_poll?: boolean | null;
  /**
   *
   * @type {string}
   * @memberof IntegrationsAnalyticsRequestThreadCreated
   */
  canvas_signed_data?: string | null;
  /**
   *
   * @type {string}
   * @memberof IntegrationsAnalyticsRequestThreadCreated
   */
  canvas_hash?: string | null;
  /**
   *
   * @type {string}
   * @memberof IntegrationsAnalyticsRequestThreadCreated
   */
  created_at?: string | null;
  /**
   *
   * @type {string}
   * @memberof IntegrationsAnalyticsRequestThreadCreated
   */
  updated_at?: string | null;
  /**
   *
   * @type {string}
   * @memberof IntegrationsAnalyticsRequestThreadCreated
   */
  last_edited?: string | null;
  /**
   *
   * @type {string}
   * @memberof IntegrationsAnalyticsRequestThreadCreated
   */
  deleted_at?: string | null;
  /**
   *
   * @type {string}
   * @memberof IntegrationsAnalyticsRequestThreadCreated
   */
  last_commented_on?: string | null;
  /**
   *
   * @type {string}
   * @memberof IntegrationsAnalyticsRequestThreadCreated
   */
  marked_as_spam_at?: string | null;
  /**
   *
   * @type {string}
   * @memberof IntegrationsAnalyticsRequestThreadCreated
   */
  archived_at?: string | null;
  /**
   *
   * @type {string}
   * @memberof IntegrationsAnalyticsRequestThreadCreated
   */
  locked_at?: string | null;
  /**
   *
   * @type {ThreadGetBulkThreads200ResponseThreadsInnerDiscordMeta}
   * @memberof IntegrationsAnalyticsRequestThreadCreated
   */
  discord_meta?: ThreadGetBulkThreads200ResponseThreadsInnerDiscordMeta | null;
  /**
   *
   * @type {number}
   * @memberof IntegrationsAnalyticsRequestThreadCreated
   */
  reaction_count: number;
  /**
   *
   * @type {number}
   * @memberof IntegrationsAnalyticsRequestThreadCreated
   */
  reaction_weights_sum: number;
  /**
   *
   * @type {number}
   * @memberof IntegrationsAnalyticsRequestThreadCreated
   */
  comment_count: number;
  /**
   *
   * @type {string}
   * @memberof IntegrationsAnalyticsRequestThreadCreated
   */
  activity_rank_date?: string | null;
  /**
   *
   * @type {number}
   * @memberof IntegrationsAnalyticsRequestThreadCreated
   */
  max_notif_id: number;
  /**
   *
   * @type {string}
   * @memberof IntegrationsAnalyticsRequestThreadCreated
   */
  created_by?: string | null;
  /**
   *
   * @type {string}
   * @memberof IntegrationsAnalyticsRequestThreadCreated
   */
  profile_name?: string | null;
  /**
   *
   * @type {Array<IntegrationsAnalyticsRequestThreadCreatedContestManagersInner>}
   * @memberof IntegrationsAnalyticsRequestThreadCreated
   */
  contestManagers?: Array<IntegrationsAnalyticsRequestThreadCreatedContestManagersInner> | null;
}
/**
 *
 * @export
 * @interface IntegrationsAnalyticsRequestThreadCreatedAddress
 */
export interface IntegrationsAnalyticsRequestThreadCreatedAddress {
  /**
   *
   * @type {number}
   * @memberof IntegrationsAnalyticsRequestThreadCreatedAddress
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof IntegrationsAnalyticsRequestThreadCreatedAddress
   */
  address: string;
  /**
   *
   * @type {string}
   * @memberof IntegrationsAnalyticsRequestThreadCreatedAddress
   */
  community_id?: string;
  /**
   *
   * @type {number}
   * @memberof IntegrationsAnalyticsRequestThreadCreatedAddress
   */
  user_id?: number | null;
  /**
   *
   * @type {string}
   * @memberof IntegrationsAnalyticsRequestThreadCreatedAddress
   */
  verification_token?: string;
  /**
   *
   * @type {string}
   * @memberof IntegrationsAnalyticsRequestThreadCreatedAddress
   */
  verification_token_expires?: string | null;
  /**
   *
   * @type {string}
   * @memberof IntegrationsAnalyticsRequestThreadCreatedAddress
   */
  verified?: string | null;
  /**
   *
   * @type {string}
   * @memberof IntegrationsAnalyticsRequestThreadCreatedAddress
   */
  last_active?: string | null;
  /**
   *
   * @type {boolean}
   * @memberof IntegrationsAnalyticsRequestThreadCreatedAddress
   */
  ghost_address?: boolean;
  /**
   *
   * @type {string}
   * @memberof IntegrationsAnalyticsRequestThreadCreatedAddress
   */
  wallet_id?: IntegrationsAnalyticsRequestThreadCreatedAddressWalletIdEnum;
  /**
   *
   * @type {string}
   * @memberof IntegrationsAnalyticsRequestThreadCreatedAddress
   */
  block_info?: string;
  /**
   *
   * @type {boolean}
   * @memberof IntegrationsAnalyticsRequestThreadCreatedAddress
   */
  is_user_default?: boolean;
  /**
   *
   * @type {string}
   * @memberof IntegrationsAnalyticsRequestThreadCreatedAddress
   */
  role?: IntegrationsAnalyticsRequestThreadCreatedAddressRoleEnum;
  /**
   *
   * @type {string}
   * @memberof IntegrationsAnalyticsRequestThreadCreatedAddress
   */
  wallet_sso_source?: IntegrationsAnalyticsRequestThreadCreatedAddressWalletSsoSourceEnum;
  /**
   *
   * @type {string}
   * @memberof IntegrationsAnalyticsRequestThreadCreatedAddress
   */
  hex?: string;
  /**
   *
   * @type {any}
   * @memberof IntegrationsAnalyticsRequestThreadCreatedAddress
   */
  created_at?: any;
  /**
   *
   * @type {any}
   * @memberof IntegrationsAnalyticsRequestThreadCreatedAddress
   */
  updated_at?: any;
  /**
   *
   * @type {UserUpdateUser200Response}
   * @memberof IntegrationsAnalyticsRequestThreadCreatedAddress
   */
  User?: UserUpdateUser200Response;
}

export const IntegrationsAnalyticsRequestThreadCreatedAddressWalletIdEnum = {
  Magic: 'magic',
  Polkadot: 'polkadot',
  Metamask: 'metamask',
  Walletconnect: 'walletconnect',
  KeplrEthereum: 'keplr-ethereum',
  Keplr: 'keplr',
  Leap: 'leap',
  Near: 'near',
  Terrastation: 'terrastation',
  TerraWalletconnect: 'terra-walletconnect',
  CosmMetamask: 'cosm-metamask',
  Phantom: 'phantom',
  Coinbase: 'coinbase',
} as const;

export type IntegrationsAnalyticsRequestThreadCreatedAddressWalletIdEnum =
  typeof IntegrationsAnalyticsRequestThreadCreatedAddressWalletIdEnum[keyof typeof IntegrationsAnalyticsRequestThreadCreatedAddressWalletIdEnum];
export const IntegrationsAnalyticsRequestThreadCreatedAddressRoleEnum = {
  Admin: 'admin',
  Moderator: 'moderator',
  Member: 'member',
} as const;

export type IntegrationsAnalyticsRequestThreadCreatedAddressRoleEnum =
  typeof IntegrationsAnalyticsRequestThreadCreatedAddressRoleEnum[keyof typeof IntegrationsAnalyticsRequestThreadCreatedAddressRoleEnum];
export const IntegrationsAnalyticsRequestThreadCreatedAddressWalletSsoSourceEnum =
  {
    Google: 'google',
    Github: 'github',
    Discord: 'discord',
    Twitter: 'twitter',
    Apple: 'apple',
    Email: 'email',
    Unknown: 'unknown',
  } as const;

export type IntegrationsAnalyticsRequestThreadCreatedAddressWalletSsoSourceEnum =
  typeof IntegrationsAnalyticsRequestThreadCreatedAddressWalletSsoSourceEnum[keyof typeof IntegrationsAnalyticsRequestThreadCreatedAddressWalletSsoSourceEnum];

/**
 *
 * @export
 * @interface IntegrationsAnalyticsRequestThreadCreatedContestManagersInner
 */
export interface IntegrationsAnalyticsRequestThreadCreatedContestManagersInner {
  /**
   *
   * @type {string}
   * @memberof IntegrationsAnalyticsRequestThreadCreatedContestManagersInner
   */
  contest_address: string;
}
/**
 *
 * @export
 * @interface LoadTestCreateJWTsRequest
 */
export interface LoadTestCreateJWTsRequest {
  /**
   *
   * @type {number}
   * @memberof LoadTestCreateJWTsRequest
   */
  number_of_jwt: number;
}
/**
 *
 * @export
 * @interface SubscriptionCreateCommentSubscription200Response
 */
export interface SubscriptionCreateCommentSubscription200Response {
  /**
   *
   * @type {number}
   * @memberof SubscriptionCreateCommentSubscription200Response
   */
  id?: number;
  /**
   *
   * @type {number}
   * @memberof SubscriptionCreateCommentSubscription200Response
   */
  user_id: number;
  /**
   *
   * @type {number}
   * @memberof SubscriptionCreateCommentSubscription200Response
   */
  comment_id: number;
  /**
   *
   * @type {string}
   * @memberof SubscriptionCreateCommentSubscription200Response
   */
  created_at?: string;
  /**
   *
   * @type {string}
   * @memberof SubscriptionCreateCommentSubscription200Response
   */
  updated_at?: string;
  /**
   *
   * @type {SubscriptionCreateCommentSubscription200ResponseComment}
   * @memberof SubscriptionCreateCommentSubscription200Response
   */
  Comment?: SubscriptionCreateCommentSubscription200ResponseComment;
}
/**
 *
 * @export
 * @interface SubscriptionCreateCommentSubscription200ResponseComment
 */
export interface SubscriptionCreateCommentSubscription200ResponseComment {
  /**
   *
   * @type {number}
   * @memberof SubscriptionCreateCommentSubscription200ResponseComment
   */
  id?: number | null;
  /**
   *
   * @type {string}
   * @memberof SubscriptionCreateCommentSubscription200ResponseComment
   */
  created_at?: string | null;
  /**
   *
   * @type {string}
   * @memberof SubscriptionCreateCommentSubscription200ResponseComment
   */
  updated_at?: string | null;
  /**
   *
   * @type {string}
   * @memberof SubscriptionCreateCommentSubscription200ResponseComment
   */
  text: string;
  /**
   *
   * @type {string}
   * @memberof SubscriptionCreateCommentSubscription200ResponseComment
   */
  plaintext: string;
  /**
   *
   * @type {SubscriptionCreateCommentSubscription200ResponseCommentThread}
   * @memberof SubscriptionCreateCommentSubscription200ResponseComment
   */
  Thread: SubscriptionCreateCommentSubscription200ResponseCommentThread;
}
/**
 *
 * @export
 * @interface SubscriptionCreateCommentSubscription200ResponseCommentThread
 */
export interface SubscriptionCreateCommentSubscription200ResponseCommentThread {
  /**
   *
   * @type {number}
   * @memberof SubscriptionCreateCommentSubscription200ResponseCommentThread
   */
  id?: number | null;
  /**
   *
   * @type {string}
   * @memberof SubscriptionCreateCommentSubscription200ResponseCommentThread
   */
  community_id: string;
  /**
   *
   * @type {string}
   * @memberof SubscriptionCreateCommentSubscription200ResponseCommentThread
   */
  title: string;
  /**
   *
   * @type {number}
   * @memberof SubscriptionCreateCommentSubscription200ResponseCommentThread
   */
  comment_count: number;
  /**
   *
   * @type {string}
   * @memberof SubscriptionCreateCommentSubscription200ResponseCommentThread
   */
  created_at?: string | null;
  /**
   *
   * @type {string}
   * @memberof SubscriptionCreateCommentSubscription200ResponseCommentThread
   */
  url?: string | null;
  /**
   *
   * @type {SubscriptionCreateCommentSubscription200ResponseCommentThreadCommunity}
   * @memberof SubscriptionCreateCommentSubscription200ResponseCommentThread
   */
  Community: SubscriptionCreateCommentSubscription200ResponseCommentThreadCommunity;
  /**
   *
   * @type {SubscriptionCreateCommentSubscription200ResponseCommentThreadAddress}
   * @memberof SubscriptionCreateCommentSubscription200ResponseCommentThread
   */
  Address: SubscriptionCreateCommentSubscription200ResponseCommentThreadAddress;
}
/**
 *
 * @export
 * @interface SubscriptionCreateCommentSubscription200ResponseCommentThreadAddress
 */
export interface SubscriptionCreateCommentSubscription200ResponseCommentThreadAddress {
  /**
   *
   * @type {number}
   * @memberof SubscriptionCreateCommentSubscription200ResponseCommentThreadAddress
   */
  id?: number;
  /**
   *
   * @type {number}
   * @memberof SubscriptionCreateCommentSubscription200ResponseCommentThreadAddress
   */
  user_id?: number | null;
  /**
   *
   * @type {string}
   * @memberof SubscriptionCreateCommentSubscription200ResponseCommentThreadAddress
   */
  address: string;
}
/**
 *
 * @export
 * @interface SubscriptionCreateCommentSubscription200ResponseCommentThreadCommunity
 */
export interface SubscriptionCreateCommentSubscription200ResponseCommentThreadCommunity {
  /**
   *
   * @type {string}
   * @memberof SubscriptionCreateCommentSubscription200ResponseCommentThreadCommunity
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof SubscriptionCreateCommentSubscription200ResponseCommentThreadCommunity
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof SubscriptionCreateCommentSubscription200ResponseCommentThreadCommunity
   */
  icon_url?: string | null;
}
/**
 *
 * @export
 * @interface SubscriptionCreateCommentSubscriptionRequest
 */
export interface SubscriptionCreateCommentSubscriptionRequest {
  /**
   *
   * @type {number}
   * @memberof SubscriptionCreateCommentSubscriptionRequest
   */
  comment_id: number;
}
/**
 *
 * @export
 * @interface SubscriptionCreateCommunityAlert200Response
 */
export interface SubscriptionCreateCommunityAlert200Response {
  /**
   *
   * @type {number}
   * @memberof SubscriptionCreateCommunityAlert200Response
   */
  user_id: number;
  /**
   *
   * @type {string}
   * @memberof SubscriptionCreateCommunityAlert200Response
   */
  community_id: string;
  /**
   *
   * @type {string}
   * @memberof SubscriptionCreateCommunityAlert200Response
   */
  created_at?: string;
  /**
   *
   * @type {string}
   * @memberof SubscriptionCreateCommunityAlert200Response
   */
  updated_at?: string;
  /**
   *
   * @type {SubscriptionCreateCommentSubscription200ResponseCommentThreadCommunity}
   * @memberof SubscriptionCreateCommunityAlert200Response
   */
  Community?: SubscriptionCreateCommentSubscription200ResponseCommentThreadCommunity;
}
/**
 *
 * @export
 * @interface SubscriptionCreateCommunityAlertRequest
 */
export interface SubscriptionCreateCommunityAlertRequest {
  /**
   *
   * @type {string}
   * @memberof SubscriptionCreateCommunityAlertRequest
   */
  community_id: string;
}
/**
 *
 * @export
 * @interface SubscriptionCreateThreadSubscription200Response
 */
export interface SubscriptionCreateThreadSubscription200Response {
  /**
   *
   * @type {number}
   * @memberof SubscriptionCreateThreadSubscription200Response
   */
  id?: number;
  /**
   *
   * @type {number}
   * @memberof SubscriptionCreateThreadSubscription200Response
   */
  user_id: number;
  /**
   *
   * @type {number}
   * @memberof SubscriptionCreateThreadSubscription200Response
   */
  thread_id: number;
  /**
   *
   * @type {string}
   * @memberof SubscriptionCreateThreadSubscription200Response
   */
  created_at?: string;
  /**
   *
   * @type {string}
   * @memberof SubscriptionCreateThreadSubscription200Response
   */
  updated_at?: string;
  /**
   *
   * @type {SubscriptionCreateThreadSubscription200ResponseThread}
   * @memberof SubscriptionCreateThreadSubscription200Response
   */
  Thread?: SubscriptionCreateThreadSubscription200ResponseThread;
}
/**
 *
 * @export
 * @interface SubscriptionCreateThreadSubscription200ResponseThread
 */
export interface SubscriptionCreateThreadSubscription200ResponseThread {
  /**
   *
   * @type {number}
   * @memberof SubscriptionCreateThreadSubscription200ResponseThread
   */
  id?: number | null;
  /**
   *
   * @type {string}
   * @memberof SubscriptionCreateThreadSubscription200ResponseThread
   */
  community_id: string;
  /**
   *
   * @type {number}
   * @memberof SubscriptionCreateThreadSubscription200ResponseThread
   */
  address_id: number;
  /**
   *
   * @type {string}
   * @memberof SubscriptionCreateThreadSubscription200ResponseThread
   */
  title: string;
  /**
   *
   * @type {number}
   * @memberof SubscriptionCreateThreadSubscription200ResponseThread
   */
  comment_count: number;
  /**
   *
   * @type {string}
   * @memberof SubscriptionCreateThreadSubscription200ResponseThread
   */
  created_at?: string | null;
  /**
   *
   * @type {string}
   * @memberof SubscriptionCreateThreadSubscription200ResponseThread
   */
  url?: string | null;
  /**
   *
   * @type {SubscriptionCreateCommentSubscription200ResponseCommentThreadCommunity}
   * @memberof SubscriptionCreateThreadSubscription200ResponseThread
   */
  Community: SubscriptionCreateCommentSubscription200ResponseCommentThreadCommunity;
  /**
   *
   * @type {SubscriptionCreateCommentSubscription200ResponseCommentThreadAddress}
   * @memberof SubscriptionCreateThreadSubscription200ResponseThread
   */
  Address: SubscriptionCreateCommentSubscription200ResponseCommentThreadAddress;
}
/**
 *
 * @export
 * @interface SubscriptionCreateThreadSubscriptionRequest
 */
export interface SubscriptionCreateThreadSubscriptionRequest {
  /**
   *
   * @type {number}
   * @memberof SubscriptionCreateThreadSubscriptionRequest
   */
  thread_id: number;
}
/**
 *
 * @export
 * @interface SubscriptionDeleteCommentSubscriptionRequest
 */
export interface SubscriptionDeleteCommentSubscriptionRequest {
  /**
   *
   * @type {Array<number>}
   * @memberof SubscriptionDeleteCommentSubscriptionRequest
   */
  comment_ids: Array<number>;
}
/**
 *
 * @export
 * @interface SubscriptionDeleteCommunityAlertRequest
 */
export interface SubscriptionDeleteCommunityAlertRequest {
  /**
   *
   * @type {Array<string>}
   * @memberof SubscriptionDeleteCommunityAlertRequest
   */
  community_ids: Array<string>;
}
/**
 *
 * @export
 * @interface SubscriptionDeleteThreadSubscriptionRequest
 */
export interface SubscriptionDeleteThreadSubscriptionRequest {
  /**
   *
   * @type {Array<number>}
   * @memberof SubscriptionDeleteThreadSubscriptionRequest
   */
  thread_ids: Array<number>;
}
/**
 *
 * @export
 * @interface SubscriptionGetSubscriptionPreferences200Response
 */
export interface SubscriptionGetSubscriptionPreferences200Response {
  /**
   *
   * @type {number}
   * @memberof SubscriptionGetSubscriptionPreferences200Response
   */
  id: number;
  /**
   *
   * @type {number}
   * @memberof SubscriptionGetSubscriptionPreferences200Response
   */
  user_id: number;
  /**
   *
   * @type {boolean}
   * @memberof SubscriptionGetSubscriptionPreferences200Response
   */
  email_notifications_enabled?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof SubscriptionGetSubscriptionPreferences200Response
   */
  digest_email_enabled?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof SubscriptionGetSubscriptionPreferences200Response
   */
  recap_email_enabled?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof SubscriptionGetSubscriptionPreferences200Response
   */
  mobile_push_notifications_enabled?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof SubscriptionGetSubscriptionPreferences200Response
   */
  mobile_push_discussion_activity_enabled?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof SubscriptionGetSubscriptionPreferences200Response
   */
  mobile_push_admin_alerts_enabled?: boolean;
  /**
   *
   * @type {string}
   * @memberof SubscriptionGetSubscriptionPreferences200Response
   */
  created_at?: string;
  /**
   *
   * @type {string}
   * @memberof SubscriptionGetSubscriptionPreferences200Response
   */
  updated_at?: string;
}
/**
 *
 * @export
 * @interface SubscriptionGetSubscriptionPreferences200ResponseAnyOf
 */
export interface SubscriptionGetSubscriptionPreferences200ResponseAnyOf {
  /**
   *
   * @type {number}
   * @memberof SubscriptionGetSubscriptionPreferences200ResponseAnyOf
   */
  id: number;
  /**
   *
   * @type {number}
   * @memberof SubscriptionGetSubscriptionPreferences200ResponseAnyOf
   */
  user_id: number;
  /**
   *
   * @type {boolean}
   * @memberof SubscriptionGetSubscriptionPreferences200ResponseAnyOf
   */
  email_notifications_enabled?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof SubscriptionGetSubscriptionPreferences200ResponseAnyOf
   */
  digest_email_enabled?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof SubscriptionGetSubscriptionPreferences200ResponseAnyOf
   */
  recap_email_enabled?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof SubscriptionGetSubscriptionPreferences200ResponseAnyOf
   */
  mobile_push_notifications_enabled?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof SubscriptionGetSubscriptionPreferences200ResponseAnyOf
   */
  mobile_push_discussion_activity_enabled?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof SubscriptionGetSubscriptionPreferences200ResponseAnyOf
   */
  mobile_push_admin_alerts_enabled?: boolean;
  /**
   *
   * @type {string}
   * @memberof SubscriptionGetSubscriptionPreferences200ResponseAnyOf
   */
  created_at?: string;
  /**
   *
   * @type {string}
   * @memberof SubscriptionGetSubscriptionPreferences200ResponseAnyOf
   */
  updated_at?: string;
}
/**
 *
 * @export
 * @interface SubscriptionRegisterClientRegistrationTokenRequest
 */
export interface SubscriptionRegisterClientRegistrationTokenRequest {
  /**
   *
   * @type {string}
   * @memberof SubscriptionRegisterClientRegistrationTokenRequest
   */
  token: string;
  /**
   *
   * @type {string}
   * @memberof SubscriptionRegisterClientRegistrationTokenRequest
   */
  channelType: SubscriptionRegisterClientRegistrationTokenRequestChannelTypeEnum;
}

export const SubscriptionRegisterClientRegistrationTokenRequestChannelTypeEnum =
  {
    Apns: 'APNS',
    Fcm: 'FCM',
  } as const;

export type SubscriptionRegisterClientRegistrationTokenRequestChannelTypeEnum =
  typeof SubscriptionRegisterClientRegistrationTokenRequestChannelTypeEnum[keyof typeof SubscriptionRegisterClientRegistrationTokenRequestChannelTypeEnum];

/**
 *
 * @export
 * @interface SubscriptionUpdateSubscriptionPreferencesRequest
 */
export interface SubscriptionUpdateSubscriptionPreferencesRequest {
  /**
   *
   * @type {boolean}
   * @memberof SubscriptionUpdateSubscriptionPreferencesRequest
   */
  email_notifications_enabled?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof SubscriptionUpdateSubscriptionPreferencesRequest
   */
  digest_email_enabled?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof SubscriptionUpdateSubscriptionPreferencesRequest
   */
  recap_email_enabled?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof SubscriptionUpdateSubscriptionPreferencesRequest
   */
  mobile_push_notifications_enabled?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof SubscriptionUpdateSubscriptionPreferencesRequest
   */
  mobile_push_discussion_activity_enabled?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof SubscriptionUpdateSubscriptionPreferencesRequest
   */
  mobile_push_admin_alerts_enabled?: boolean;
}
/**
 *
 * @export
 * @interface ThreadGetBulkThreads200Response
 */
export interface ThreadGetBulkThreads200Response {
  /**
   *
   * @type {number}
   * @memberof ThreadGetBulkThreads200Response
   */
  limit: number;
  /**
   *
   * @type {number}
   * @memberof ThreadGetBulkThreads200Response
   */
  numVotingThreads: number;
  /**
   *
   * @type {number}
   * @memberof ThreadGetBulkThreads200Response
   */
  cursor: number;
  /**
   *
   * @type {Array<ThreadGetBulkThreads200ResponseThreadsInner>}
   * @memberof ThreadGetBulkThreads200Response
   */
  threads: Array<ThreadGetBulkThreads200ResponseThreadsInner>;
}
/**
 *
 * @export
 * @interface ThreadGetBulkThreads200ResponseThreadsInner
 */
export interface ThreadGetBulkThreads200ResponseThreadsInner {
  /**
   *
   * @type {number}
   * @memberof ThreadGetBulkThreads200ResponseThreadsInner
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof ThreadGetBulkThreads200ResponseThreadsInner
   */
  title: string;
  /**
   *
   * @type {string}
   * @memberof ThreadGetBulkThreads200ResponseThreadsInner
   */
  url: string | null;
  /**
   *
   * @type {string}
   * @memberof ThreadGetBulkThreads200ResponseThreadsInner
   */
  body: string;
  /**
   *
   * @type {string}
   * @memberof ThreadGetBulkThreads200ResponseThreadsInner
   */
  last_edited?: string | null;
  /**
   *
   * @type {string}
   * @memberof ThreadGetBulkThreads200ResponseThreadsInner
   */
  kind: string;
  /**
   *
   * @type {string}
   * @memberof ThreadGetBulkThreads200ResponseThreadsInner
   */
  stage: string;
  /**
   *
   * @type {boolean}
   * @memberof ThreadGetBulkThreads200ResponseThreadsInner
   */
  read_only: boolean;
  /**
   *
   * @type {ThreadGetBulkThreads200ResponseThreadsInnerDiscordMeta}
   * @memberof ThreadGetBulkThreads200ResponseThreadsInner
   */
  discord_meta?: ThreadGetBulkThreads200ResponseThreadsInnerDiscordMeta | null;
  /**
   *
   * @type {boolean}
   * @memberof ThreadGetBulkThreads200ResponseThreadsInner
   */
  pinned: boolean;
  /**
   *
   * @type {string}
   * @memberof ThreadGetBulkThreads200ResponseThreadsInner
   */
  chain: string;
  /**
   *
   * @type {string}
   * @memberof ThreadGetBulkThreads200ResponseThreadsInner
   */
  created_at: string;
  /**
   *
   * @type {string}
   * @memberof ThreadGetBulkThreads200ResponseThreadsInner
   */
  updated_at: string;
  /**
   *
   * @type {string}
   * @memberof ThreadGetBulkThreads200ResponseThreadsInner
   */
  locked_at?: string | null;
  /**
   *
   * @type {Array<ThreadGetBulkThreads200ResponseThreadsInnerLinksInner>}
   * @memberof ThreadGetBulkThreads200ResponseThreadsInner
   */
  links?: Array<ThreadGetBulkThreads200ResponseThreadsInnerLinksInner> | null;
  /**
   *
   * @type {Array<string>}
   * @memberof ThreadGetBulkThreads200ResponseThreadsInner
   */
  collaborators: Array<string>;
  /**
   *
   * @type {boolean}
   * @memberof ThreadGetBulkThreads200ResponseThreadsInner
   */
  has_poll?: boolean | null;
  /**
   *
   * @type {string}
   * @memberof ThreadGetBulkThreads200ResponseThreadsInner
   */
  last_commented_on?: string | null;
  /**
   *
   * @type {string}
   * @memberof ThreadGetBulkThreads200ResponseThreadsInner
   */
  plaintext?: string | null;
  /**
   *
   * @type {ThreadGetBulkThreads200ResponseThreadsInnerAddress}
   * @memberof ThreadGetBulkThreads200ResponseThreadsInner
   */
  Address: ThreadGetBulkThreads200ResponseThreadsInnerAddress;
  /**
   *
   * @type {number}
   * @memberof ThreadGetBulkThreads200ResponseThreadsInner
   */
  numberOfComments: number;
  /**
   *
   * @type {Array<string>}
   * @memberof ThreadGetBulkThreads200ResponseThreadsInner
   */
  reactionIds: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof ThreadGetBulkThreads200ResponseThreadsInner
   */
  reactionTimestamps: Array<string>;
  /**
   *
   * @type {Array<number>}
   * @memberof ThreadGetBulkThreads200ResponseThreadsInner
   */
  reactionWeights: Array<number>;
  /**
   *
   * @type {number}
   * @memberof ThreadGetBulkThreads200ResponseThreadsInner
   */
  reaction_weights_sum: number;
  /**
   *
   * @type {Array<string>}
   * @memberof ThreadGetBulkThreads200ResponseThreadsInner
   */
  addressesReacted: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof ThreadGetBulkThreads200ResponseThreadsInner
   */
  reactedProfileName?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof ThreadGetBulkThreads200ResponseThreadsInner
   */
  reactedProfileAvatarUrl?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof ThreadGetBulkThreads200ResponseThreadsInner
   */
  reactedAddressLastActive?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof ThreadGetBulkThreads200ResponseThreadsInner
   */
  reactionType: Array<string>;
  /**
   *
   * @type {string}
   * @memberof ThreadGetBulkThreads200ResponseThreadsInner
   */
  marked_as_spam_at?: string | null;
  /**
   *
   * @type {string}
   * @memberof ThreadGetBulkThreads200ResponseThreadsInner
   */
  archived_at?: string | null;
  /**
   *
   * @type {string}
   * @memberof ThreadGetBulkThreads200ResponseThreadsInner
   */
  latest_activity?: string | null;
  /**
   *
   * @type {ThreadGetBulkThreads200ResponseThreadsInnerTopic}
   * @memberof ThreadGetBulkThreads200ResponseThreadsInner
   */
  topic?: ThreadGetBulkThreads200ResponseThreadsInnerTopic;
  /**
   *
   * @type {number}
   * @memberof ThreadGetBulkThreads200ResponseThreadsInner
   */
  user_id: number;
  /**
   *
   * @type {string}
   * @memberof ThreadGetBulkThreads200ResponseThreadsInner
   */
  avatar_url: string | null;
  /**
   *
   * @type {string}
   * @memberof ThreadGetBulkThreads200ResponseThreadsInner
   */
  address_last_active: string | null;
  /**
   *
   * @type {string}
   * @memberof ThreadGetBulkThreads200ResponseThreadsInner
   */
  profile_name: string | null;
}
/**
 *
 * @export
 * @interface ThreadGetBulkThreads200ResponseThreadsInnerAddress
 */
export interface ThreadGetBulkThreads200ResponseThreadsInnerAddress {
  /**
   *
   * @type {number}
   * @memberof ThreadGetBulkThreads200ResponseThreadsInnerAddress
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof ThreadGetBulkThreads200ResponseThreadsInnerAddress
   */
  address: string;
  /**
   *
   * @type {string}
   * @memberof ThreadGetBulkThreads200ResponseThreadsInnerAddress
   */
  community_id: string;
}
/**
 *
 * @export
 * @interface ThreadGetBulkThreads200ResponseThreadsInnerDiscordMeta
 */
export interface ThreadGetBulkThreads200ResponseThreadsInnerDiscordMeta {
  /**
   *
   * @type {ThreadGetBulkThreads200ResponseThreadsInnerDiscordMetaUser}
   * @memberof ThreadGetBulkThreads200ResponseThreadsInnerDiscordMeta
   */
  user: ThreadGetBulkThreads200ResponseThreadsInnerDiscordMetaUser;
  /**
   *
   * @type {string}
   * @memberof ThreadGetBulkThreads200ResponseThreadsInnerDiscordMeta
   */
  channel_id: string;
  /**
   *
   * @type {string}
   * @memberof ThreadGetBulkThreads200ResponseThreadsInnerDiscordMeta
   */
  message_id: string;
}
/**
 *
 * @export
 * @interface ThreadGetBulkThreads200ResponseThreadsInnerDiscordMetaUser
 */
export interface ThreadGetBulkThreads200ResponseThreadsInnerDiscordMetaUser {
  /**
   *
   * @type {string}
   * @memberof ThreadGetBulkThreads200ResponseThreadsInnerDiscordMetaUser
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof ThreadGetBulkThreads200ResponseThreadsInnerDiscordMetaUser
   */
  username: string;
}
/**
 *
 * @export
 * @interface ThreadGetBulkThreads200ResponseThreadsInnerLinksInner
 */
export interface ThreadGetBulkThreads200ResponseThreadsInnerLinksInner {
  /**
   *
   * @type {string}
   * @memberof ThreadGetBulkThreads200ResponseThreadsInnerLinksInner
   */
  source: ThreadGetBulkThreads200ResponseThreadsInnerLinksInnerSourceEnum;
  /**
   *
   * @type {string}
   * @memberof ThreadGetBulkThreads200ResponseThreadsInnerLinksInner
   */
  identifier: string;
  /**
   *
   * @type {string}
   * @memberof ThreadGetBulkThreads200ResponseThreadsInnerLinksInner
   */
  title?: string | null;
}

export const ThreadGetBulkThreads200ResponseThreadsInnerLinksInnerSourceEnum = {
  Snapshot: 'snapshot',
  Proposal: 'proposal',
  Thread: 'thread',
  Web: 'web',
  Template: 'template',
} as const;

export type ThreadGetBulkThreads200ResponseThreadsInnerLinksInnerSourceEnum =
  typeof ThreadGetBulkThreads200ResponseThreadsInnerLinksInnerSourceEnum[keyof typeof ThreadGetBulkThreads200ResponseThreadsInnerLinksInnerSourceEnum];

/**
 *
 * @export
 * @interface ThreadGetBulkThreads200ResponseThreadsInnerTopic
 */
export interface ThreadGetBulkThreads200ResponseThreadsInnerTopic {
  /**
   *
   * @type {number}
   * @memberof ThreadGetBulkThreads200ResponseThreadsInnerTopic
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof ThreadGetBulkThreads200ResponseThreadsInnerTopic
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof ThreadGetBulkThreads200ResponseThreadsInnerTopic
   */
  description: string;
  /**
   *
   * @type {string}
   * @memberof ThreadGetBulkThreads200ResponseThreadsInnerTopic
   */
  chainId: string;
  /**
   *
   * @type {string}
   * @memberof ThreadGetBulkThreads200ResponseThreadsInnerTopic
   */
  telegram: string;
}
/**
 *
 * @export
 * @interface UserUpdateUser200Response
 */
export interface UserUpdateUser200Response {
  /**
   *
   * @type {number}
   * @memberof UserUpdateUser200Response
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof UserUpdateUser200Response
   */
  email?: string | null;
  /**
   *
   * @type {boolean}
   * @memberof UserUpdateUser200Response
   */
  isAdmin?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof UserUpdateUser200Response
   */
  disableRichText?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof UserUpdateUser200Response
   */
  emailVerified?: boolean | null;
  /**
   *
   * @type {string}
   * @memberof UserUpdateUser200Response
   */
  selected_community_id?: string | null;
  /**
   *
   * @type {string}
   * @memberof UserUpdateUser200Response
   */
  emailNotificationInterval?: UserUpdateUser200ResponseEmailNotificationIntervalEnum;
  /**
   *
   * @type {boolean}
   * @memberof UserUpdateUser200Response
   */
  promotional_emails_enabled?: boolean | null;
  /**
   *
   * @type {boolean}
   * @memberof UserUpdateUser200Response
   */
  is_welcome_onboard_flow_complete?: boolean;
  /**
   *
   * @type {UserUpdateUserRequestProfile}
   * @memberof UserUpdateUser200Response
   */
  profile: UserUpdateUserRequestProfile;
  /**
   *
   * @type {any}
   * @memberof UserUpdateUser200Response
   */
  created_at?: any;
  /**
   *
   * @type {any}
   * @memberof UserUpdateUser200Response
   */
  updated_at?: any;
  /**
   *
   * @type {Array<UserUpdateUserRequestProfileTagsInner>}
   * @memberof UserUpdateUser200Response
   */
  ProfileTags?: Array<UserUpdateUserRequestProfileTagsInner>;
}

export const UserUpdateUser200ResponseEmailNotificationIntervalEnum = {
  Weekly: 'weekly',
  Never: 'never',
} as const;

export type UserUpdateUser200ResponseEmailNotificationIntervalEnum =
  typeof UserUpdateUser200ResponseEmailNotificationIntervalEnum[keyof typeof UserUpdateUser200ResponseEmailNotificationIntervalEnum];

/**
 *
 * @export
 * @interface UserUpdateUserDefaultResponse
 */
export interface UserUpdateUserDefaultResponse {
  /**
   *
   * @type {string}
   * @memberof UserUpdateUserDefaultResponse
   */
  message: string;
  /**
   *
   * @type {string}
   * @memberof UserUpdateUserDefaultResponse
   */
  code: string;
  /**
   *
   * @type {Array<UserUpdateUserDefaultResponseIssuesInner>}
   * @memberof UserUpdateUserDefaultResponse
   */
  issues?: Array<UserUpdateUserDefaultResponseIssuesInner>;
}
/**
 *
 * @export
 * @interface UserUpdateUserDefaultResponseIssuesInner
 */
export interface UserUpdateUserDefaultResponseIssuesInner {
  /**
   *
   * @type {string}
   * @memberof UserUpdateUserDefaultResponseIssuesInner
   */
  message: string;
}
/**
 *
 * @export
 * @interface UserUpdateUserRequest
 */
export interface UserUpdateUserRequest {
  /**
   *
   * @type {string}
   * @memberof UserUpdateUserRequest
   */
  email?: string | null;
  /**
   *
   * @type {boolean}
   * @memberof UserUpdateUserRequest
   */
  isAdmin?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof UserUpdateUserRequest
   */
  disableRichText?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof UserUpdateUserRequest
   */
  emailVerified?: boolean | null;
  /**
   *
   * @type {string}
   * @memberof UserUpdateUserRequest
   */
  selected_community_id?: string | null;
  /**
   *
   * @type {string}
   * @memberof UserUpdateUserRequest
   */
  emailNotificationInterval?: UserUpdateUserRequestEmailNotificationIntervalEnum;
  /**
   *
   * @type {boolean}
   * @memberof UserUpdateUserRequest
   */
  promotional_emails_enabled?: boolean | null;
  /**
   *
   * @type {UserUpdateUserRequestProfile}
   * @memberof UserUpdateUserRequest
   */
  profile: UserUpdateUserRequestProfile;
  /**
   *
   * @type {any}
   * @memberof UserUpdateUserRequest
   */
  created_at?: any;
  /**
   *
   * @type {any}
   * @memberof UserUpdateUserRequest
   */
  updated_at?: any;
  /**
   *
   * @type {Array<UserUpdateUserRequestProfileTagsInner>}
   * @memberof UserUpdateUserRequest
   */
  ProfileTags?: Array<UserUpdateUserRequestProfileTagsInner>;
  /**
   *
   * @type {Array<number>}
   * @memberof UserUpdateUserRequest
   */
  tag_ids?: Array<number> | null;
}

export const UserUpdateUserRequestEmailNotificationIntervalEnum = {
  Weekly: 'weekly',
  Never: 'never',
} as const;

export type UserUpdateUserRequestEmailNotificationIntervalEnum =
  typeof UserUpdateUserRequestEmailNotificationIntervalEnum[keyof typeof UserUpdateUserRequestEmailNotificationIntervalEnum];

/**
 *
 * @export
 * @interface UserUpdateUserRequestProfile
 */
export interface UserUpdateUserRequestProfile {
  /**
   *
   * @type {string}
   * @memberof UserUpdateUserRequestProfile
   */
  name?: string | null;
  /**
   *
   * @type {string}
   * @memberof UserUpdateUserRequestProfile
   */
  email?: string | null;
  /**
   *
   * @type {string}
   * @memberof UserUpdateUserRequestProfile
   */
  website?: string | null;
  /**
   *
   * @type {string}
   * @memberof UserUpdateUserRequestProfile
   */
  bio?: string | null;
  /**
   *
   * @type {string}
   * @memberof UserUpdateUserRequestProfile
   */
  avatar_url?: string | null;
  /**
   *
   * @type {string}
   * @memberof UserUpdateUserRequestProfile
   */
  slug?: string | null;
  /**
   *
   * @type {Array<string>}
   * @memberof UserUpdateUserRequestProfile
   */
  socials?: Array<string> | null;
  /**
   *
   * @type {UserUpdateUserRequestProfileBackgroundImage}
   * @memberof UserUpdateUserRequestProfile
   */
  background_image?: UserUpdateUserRequestProfileBackgroundImage | null;
}
/**
 *
 * @export
 * @interface UserUpdateUserRequestProfileBackgroundImage
 */
export interface UserUpdateUserRequestProfileBackgroundImage {
  /**
   *
   * @type {string}
   * @memberof UserUpdateUserRequestProfileBackgroundImage
   */
  url?: string;
  /**
   *
   * @type {string}
   * @memberof UserUpdateUserRequestProfileBackgroundImage
   */
  imageBehavior?: string;
}
/**
 *
 * @export
 * @interface UserUpdateUserRequestProfileTagsInner
 */
export interface UserUpdateUserRequestProfileTagsInner {
  /**
   *
   * @type {number}
   * @memberof UserUpdateUserRequestProfileTagsInner
   */
  user_id: number;
  /**
   *
   * @type {number}
   * @memberof UserUpdateUserRequestProfileTagsInner
   */
  tag_id: number;
  /**
   *
   * @type {string}
   * @memberof UserUpdateUserRequestProfileTagsInner
   */
  created_at?: string;
  /**
   *
   * @type {string}
   * @memberof UserUpdateUserRequestProfileTagsInner
   */
  updated_at?: string;
}

/**
 * CommunityApi - axios parameter creator
 * @export
 */
export const CommunityApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @param {string} addressId
     * @param {string} id
     * @param {CommunityCreateGroupRequest} communityCreateGroupRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    communityCreateGroup: async (
      addressId: string,
      id: string,
      communityCreateGroupRequest: CommunityCreateGroupRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'addressId' is not null or undefined
      assertParamExists('communityCreateGroup', 'addressId', addressId);
      // verify required parameter 'id' is not null or undefined
      assertParamExists('communityCreateGroup', 'id', id);
      // verify required parameter 'communityCreateGroupRequest' is not null or undefined
      assertParamExists(
        'communityCreateGroup',
        'communityCreateGroupRequest',
        communityCreateGroupRequest,
      );
      const localVarPath = `/CreateGroup/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (addressId != null) {
        localVarHeaderParameter['address_id'] = String(addressId);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        communityCreateGroupRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} addressId
     * @param {string} id
     * @param {CommunityCreateStakeTransactionRequest} communityCreateStakeTransactionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    communityCreateStakeTransaction: async (
      addressId: string,
      id: string,
      communityCreateStakeTransactionRequest: CommunityCreateStakeTransactionRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'addressId' is not null or undefined
      assertParamExists(
        'communityCreateStakeTransaction',
        'addressId',
        addressId,
      );
      // verify required parameter 'id' is not null or undefined
      assertParamExists('communityCreateStakeTransaction', 'id', id);
      // verify required parameter 'communityCreateStakeTransactionRequest' is not null or undefined
      assertParamExists(
        'communityCreateStakeTransaction',
        'communityCreateStakeTransactionRequest',
        communityCreateStakeTransactionRequest,
      );
      const localVarPath = `/CreateStakeTransaction/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (addressId != null) {
        localVarHeaderParameter['address_id'] = String(addressId);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        communityCreateStakeTransactionRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} addressId
     * @param {string} id
     * @param {CommunitySetStakeRequest} communitySetStakeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    communitySetStake: async (
      addressId: string,
      id: string,
      communitySetStakeRequest: CommunitySetStakeRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'addressId' is not null or undefined
      assertParamExists('communitySetStake', 'addressId', addressId);
      // verify required parameter 'id' is not null or undefined
      assertParamExists('communitySetStake', 'id', id);
      // verify required parameter 'communitySetStakeRequest' is not null or undefined
      assertParamExists(
        'communitySetStake',
        'communitySetStakeRequest',
        communitySetStakeRequest,
      );
      const localVarPath = `/SetCommunityStake/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (addressId != null) {
        localVarHeaderParameter['address_id'] = String(addressId);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        communitySetStakeRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} addressId
     * @param {string} id
     * @param {IntegrationsAnalyticsRequestThreadCreatedContestManagersInner} integrationsAnalyticsRequestThreadCreatedContestManagersInner
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    contestCancelContestMetadata: async (
      addressId: string,
      id: string,
      integrationsAnalyticsRequestThreadCreatedContestManagersInner: IntegrationsAnalyticsRequestThreadCreatedContestManagersInner,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'addressId' is not null or undefined
      assertParamExists('contestCancelContestMetadata', 'addressId', addressId);
      // verify required parameter 'id' is not null or undefined
      assertParamExists('contestCancelContestMetadata', 'id', id);
      // verify required parameter 'integrationsAnalyticsRequestThreadCreatedContestManagersInner' is not null or undefined
      assertParamExists(
        'contestCancelContestMetadata',
        'integrationsAnalyticsRequestThreadCreatedContestManagersInner',
        integrationsAnalyticsRequestThreadCreatedContestManagersInner,
      );
      const localVarPath = `/CancelContestManagerMetadata/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (addressId != null) {
        localVarHeaderParameter['address_id'] = String(addressId);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        integrationsAnalyticsRequestThreadCreatedContestManagersInner,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} addressId
     * @param {string} id
     * @param {ContestCreateContestMetadataRequest} contestCreateContestMetadataRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    contestCreateContestMetadata: async (
      addressId: string,
      id: string,
      contestCreateContestMetadataRequest: ContestCreateContestMetadataRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'addressId' is not null or undefined
      assertParamExists('contestCreateContestMetadata', 'addressId', addressId);
      // verify required parameter 'id' is not null or undefined
      assertParamExists('contestCreateContestMetadata', 'id', id);
      // verify required parameter 'contestCreateContestMetadataRequest' is not null or undefined
      assertParamExists(
        'contestCreateContestMetadata',
        'contestCreateContestMetadataRequest',
        contestCreateContestMetadataRequest,
      );
      const localVarPath = `/CreateContestManagerMetadata/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (addressId != null) {
        localVarHeaderParameter['address_id'] = String(addressId);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        contestCreateContestMetadataRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} addressId
     * @param {string} id
     * @param {ContestUpdateContestMetadataRequest} contestUpdateContestMetadataRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    contestUpdateContestMetadata: async (
      addressId: string,
      id: string,
      contestUpdateContestMetadataRequest: ContestUpdateContestMetadataRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'addressId' is not null or undefined
      assertParamExists('contestUpdateContestMetadata', 'addressId', addressId);
      // verify required parameter 'id' is not null or undefined
      assertParamExists('contestUpdateContestMetadata', 'id', id);
      // verify required parameter 'contestUpdateContestMetadataRequest' is not null or undefined
      assertParamExists(
        'contestUpdateContestMetadata',
        'contestUpdateContestMetadataRequest',
        contestUpdateContestMetadataRequest,
      );
      const localVarPath = `/UpdateContestManagerMetadata/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (addressId != null) {
        localVarHeaderParameter['address_id'] = String(addressId);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        contestUpdateContestMetadataRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * CommunityApi - functional programming interface
 * @export
 */
export const CommunityApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    CommunityApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {string} addressId
     * @param {string} id
     * @param {CommunityCreateGroupRequest} communityCreateGroupRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async communityCreateGroup(
      addressId: string,
      id: string,
      communityCreateGroupRequest: CommunityCreateGroupRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<CommunitySetStake200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.communityCreateGroup(
          addressId,
          id,
          communityCreateGroupRequest,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['CommunityApi.communityCreateGroup']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} addressId
     * @param {string} id
     * @param {CommunityCreateStakeTransactionRequest} communityCreateStakeTransactionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async communityCreateStakeTransaction(
      addressId: string,
      id: string,
      communityCreateStakeTransactionRequest: CommunityCreateStakeTransactionRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<CommunityGetCommunity200ResponseCommunityStakesInnerStakeTransactionsInner>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.communityCreateStakeTransaction(
          addressId,
          id,
          communityCreateStakeTransactionRequest,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['CommunityApi.communityCreateStakeTransaction']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} addressId
     * @param {string} id
     * @param {CommunitySetStakeRequest} communitySetStakeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async communitySetStake(
      addressId: string,
      id: string,
      communitySetStakeRequest: CommunitySetStakeRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<CommunitySetStake200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.communitySetStake(
          addressId,
          id,
          communitySetStakeRequest,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['CommunityApi.communitySetStake']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} addressId
     * @param {string} id
     * @param {IntegrationsAnalyticsRequestThreadCreatedContestManagersInner} integrationsAnalyticsRequestThreadCreatedContestManagersInner
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async contestCancelContestMetadata(
      addressId: string,
      id: string,
      integrationsAnalyticsRequestThreadCreatedContestManagersInner: IntegrationsAnalyticsRequestThreadCreatedContestManagersInner,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ContestCreateContestMetadata200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.contestCancelContestMetadata(
          addressId,
          id,
          integrationsAnalyticsRequestThreadCreatedContestManagersInner,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['CommunityApi.contestCancelContestMetadata']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} addressId
     * @param {string} id
     * @param {ContestCreateContestMetadataRequest} contestCreateContestMetadataRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async contestCreateContestMetadata(
      addressId: string,
      id: string,
      contestCreateContestMetadataRequest: ContestCreateContestMetadataRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ContestCreateContestMetadata200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.contestCreateContestMetadata(
          addressId,
          id,
          contestCreateContestMetadataRequest,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['CommunityApi.contestCreateContestMetadata']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} addressId
     * @param {string} id
     * @param {ContestUpdateContestMetadataRequest} contestUpdateContestMetadataRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async contestUpdateContestMetadata(
      addressId: string,
      id: string,
      contestUpdateContestMetadataRequest: ContestUpdateContestMetadataRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ContestCreateContestMetadata200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.contestUpdateContestMetadata(
          addressId,
          id,
          contestUpdateContestMetadataRequest,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['CommunityApi.contestUpdateContestMetadata']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * CommunityApi - factory interface
 * @export
 */
export const CommunityApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = CommunityApiFp(configuration);
  return {
    /**
     *
     * @param {string} addressId
     * @param {string} id
     * @param {CommunityCreateGroupRequest} communityCreateGroupRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    communityCreateGroup(
      addressId: string,
      id: string,
      communityCreateGroupRequest: CommunityCreateGroupRequest,
      options?: any,
    ): AxiosPromise<CommunitySetStake200Response> {
      return localVarFp
        .communityCreateGroup(
          addressId,
          id,
          communityCreateGroupRequest,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} addressId
     * @param {string} id
     * @param {CommunityCreateStakeTransactionRequest} communityCreateStakeTransactionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    communityCreateStakeTransaction(
      addressId: string,
      id: string,
      communityCreateStakeTransactionRequest: CommunityCreateStakeTransactionRequest,
      options?: any,
    ): AxiosPromise<CommunityGetCommunity200ResponseCommunityStakesInnerStakeTransactionsInner> {
      return localVarFp
        .communityCreateStakeTransaction(
          addressId,
          id,
          communityCreateStakeTransactionRequest,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} addressId
     * @param {string} id
     * @param {CommunitySetStakeRequest} communitySetStakeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    communitySetStake(
      addressId: string,
      id: string,
      communitySetStakeRequest: CommunitySetStakeRequest,
      options?: any,
    ): AxiosPromise<CommunitySetStake200Response> {
      return localVarFp
        .communitySetStake(addressId, id, communitySetStakeRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} addressId
     * @param {string} id
     * @param {IntegrationsAnalyticsRequestThreadCreatedContestManagersInner} integrationsAnalyticsRequestThreadCreatedContestManagersInner
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    contestCancelContestMetadata(
      addressId: string,
      id: string,
      integrationsAnalyticsRequestThreadCreatedContestManagersInner: IntegrationsAnalyticsRequestThreadCreatedContestManagersInner,
      options?: any,
    ): AxiosPromise<ContestCreateContestMetadata200Response> {
      return localVarFp
        .contestCancelContestMetadata(
          addressId,
          id,
          integrationsAnalyticsRequestThreadCreatedContestManagersInner,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} addressId
     * @param {string} id
     * @param {ContestCreateContestMetadataRequest} contestCreateContestMetadataRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    contestCreateContestMetadata(
      addressId: string,
      id: string,
      contestCreateContestMetadataRequest: ContestCreateContestMetadataRequest,
      options?: any,
    ): AxiosPromise<ContestCreateContestMetadata200Response> {
      return localVarFp
        .contestCreateContestMetadata(
          addressId,
          id,
          contestCreateContestMetadataRequest,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} addressId
     * @param {string} id
     * @param {ContestUpdateContestMetadataRequest} contestUpdateContestMetadataRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    contestUpdateContestMetadata(
      addressId: string,
      id: string,
      contestUpdateContestMetadataRequest: ContestUpdateContestMetadataRequest,
      options?: any,
    ): AxiosPromise<ContestCreateContestMetadata200Response> {
      return localVarFp
        .contestUpdateContestMetadata(
          addressId,
          id,
          contestUpdateContestMetadataRequest,
          options,
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * CommunityApi - object-oriented interface
 * @export
 * @class CommunityApi
 * @extends {BaseAPI}
 */
export class CommunityApi extends BaseAPI {
  /**
   *
   * @param {string} addressId
   * @param {string} id
   * @param {CommunityCreateGroupRequest} communityCreateGroupRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CommunityApi
   */
  public communityCreateGroup(
    addressId: string,
    id: string,
    communityCreateGroupRequest: CommunityCreateGroupRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return CommunityApiFp(this.configuration)
      .communityCreateGroup(addressId, id, communityCreateGroupRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} addressId
   * @param {string} id
   * @param {CommunityCreateStakeTransactionRequest} communityCreateStakeTransactionRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CommunityApi
   */
  public communityCreateStakeTransaction(
    addressId: string,
    id: string,
    communityCreateStakeTransactionRequest: CommunityCreateStakeTransactionRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return CommunityApiFp(this.configuration)
      .communityCreateStakeTransaction(
        addressId,
        id,
        communityCreateStakeTransactionRequest,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} addressId
   * @param {string} id
   * @param {CommunitySetStakeRequest} communitySetStakeRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CommunityApi
   */
  public communitySetStake(
    addressId: string,
    id: string,
    communitySetStakeRequest: CommunitySetStakeRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return CommunityApiFp(this.configuration)
      .communitySetStake(addressId, id, communitySetStakeRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} addressId
   * @param {string} id
   * @param {IntegrationsAnalyticsRequestThreadCreatedContestManagersInner} integrationsAnalyticsRequestThreadCreatedContestManagersInner
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CommunityApi
   */
  public contestCancelContestMetadata(
    addressId: string,
    id: string,
    integrationsAnalyticsRequestThreadCreatedContestManagersInner: IntegrationsAnalyticsRequestThreadCreatedContestManagersInner,
    options?: RawAxiosRequestConfig,
  ) {
    return CommunityApiFp(this.configuration)
      .contestCancelContestMetadata(
        addressId,
        id,
        integrationsAnalyticsRequestThreadCreatedContestManagersInner,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} addressId
   * @param {string} id
   * @param {ContestCreateContestMetadataRequest} contestCreateContestMetadataRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CommunityApi
   */
  public contestCreateContestMetadata(
    addressId: string,
    id: string,
    contestCreateContestMetadataRequest: ContestCreateContestMetadataRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return CommunityApiFp(this.configuration)
      .contestCreateContestMetadata(
        addressId,
        id,
        contestCreateContestMetadataRequest,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} addressId
   * @param {string} id
   * @param {ContestUpdateContestMetadataRequest} contestUpdateContestMetadataRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CommunityApi
   */
  public contestUpdateContestMetadata(
    addressId: string,
    id: string,
    contestUpdateContestMetadataRequest: ContestUpdateContestMetadataRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return CommunityApiFp(this.configuration)
      .contestUpdateContestMetadata(
        addressId,
        id,
        contestUpdateContestMetadataRequest,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * IntegrationApi - axios parameter creator
 * @export
 */
export const IntegrationApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @param {IntegrationsAnalyticsRequest} integrationsAnalyticsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    integrationsAnalytics: async (
      integrationsAnalyticsRequest: IntegrationsAnalyticsRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'integrationsAnalyticsRequest' is not null or undefined
      assertParamExists(
        'integrationsAnalytics',
        'integrationsAnalyticsRequest',
        integrationsAnalyticsRequest,
      );
      const localVarPath = `/Analytics`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        integrationsAnalyticsRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * IntegrationApi - functional programming interface
 * @export
 */
export const IntegrationApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    IntegrationApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {IntegrationsAnalyticsRequest} integrationsAnalyticsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async integrationsAnalytics(
      integrationsAnalyticsRequest: IntegrationsAnalyticsRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.integrationsAnalytics(
          integrationsAnalyticsRequest,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['IntegrationApi.integrationsAnalytics']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * IntegrationApi - factory interface
 * @export
 */
export const IntegrationApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = IntegrationApiFp(configuration);
  return {
    /**
     *
     * @param {IntegrationsAnalyticsRequest} integrationsAnalyticsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    integrationsAnalytics(
      integrationsAnalyticsRequest: IntegrationsAnalyticsRequest,
      options?: any,
    ): AxiosPromise<object> {
      return localVarFp
        .integrationsAnalytics(integrationsAnalyticsRequest, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * IntegrationApi - object-oriented interface
 * @export
 * @class IntegrationApi
 * @extends {BaseAPI}
 */
export class IntegrationApi extends BaseAPI {
  /**
   *
   * @param {IntegrationsAnalyticsRequest} integrationsAnalyticsRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IntegrationApi
   */
  public integrationsAnalytics(
    integrationsAnalyticsRequest: IntegrationsAnalyticsRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return IntegrationApiFp(this.configuration)
      .integrationsAnalytics(integrationsAnalyticsRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * LoadTestApi - axios parameter creator
 * @export
 */
export const LoadTestApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @param {string} addressId
     * @param {number} id
     * @param {LoadTestCreateJWTsRequest} loadTestCreateJWTsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    loadTestCreateJWTs: async (
      addressId: string,
      id: number,
      loadTestCreateJWTsRequest: LoadTestCreateJWTsRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'addressId' is not null or undefined
      assertParamExists('loadTestCreateJWTs', 'addressId', addressId);
      // verify required parameter 'id' is not null or undefined
      assertParamExists('loadTestCreateJWTs', 'id', id);
      // verify required parameter 'loadTestCreateJWTsRequest' is not null or undefined
      assertParamExists(
        'loadTestCreateJWTs',
        'loadTestCreateJWTsRequest',
        loadTestCreateJWTsRequest,
      );
      const localVarPath = `/CreateJWTs/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'oauth2',
        [],
        configuration,
      );

      if (addressId != null) {
        localVarHeaderParameter['address_id'] = String(addressId);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        loadTestCreateJWTsRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * LoadTestApi - functional programming interface
 * @export
 */
export const LoadTestApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = LoadTestApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {string} addressId
     * @param {number} id
     * @param {LoadTestCreateJWTsRequest} loadTestCreateJWTsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async loadTestCreateJWTs(
      addressId: string,
      id: number,
      loadTestCreateJWTsRequest: LoadTestCreateJWTsRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.loadTestCreateJWTs(
          addressId,
          id,
          loadTestCreateJWTsRequest,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['LoadTestApi.loadTestCreateJWTs']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * LoadTestApi - factory interface
 * @export
 */
export const LoadTestApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = LoadTestApiFp(configuration);
  return {
    /**
     *
     * @param {string} addressId
     * @param {number} id
     * @param {LoadTestCreateJWTsRequest} loadTestCreateJWTsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    loadTestCreateJWTs(
      addressId: string,
      id: number,
      loadTestCreateJWTsRequest: LoadTestCreateJWTsRequest,
      options?: any,
    ): AxiosPromise<Array<string>> {
      return localVarFp
        .loadTestCreateJWTs(addressId, id, loadTestCreateJWTsRequest, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * LoadTestApi - object-oriented interface
 * @export
 * @class LoadTestApi
 * @extends {BaseAPI}
 */
export class LoadTestApi extends BaseAPI {
  /**
   *
   * @param {string} addressId
   * @param {number} id
   * @param {LoadTestCreateJWTsRequest} loadTestCreateJWTsRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LoadTestApi
   */
  public loadTestCreateJWTs(
    addressId: string,
    id: number,
    loadTestCreateJWTsRequest: LoadTestCreateJWTsRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return LoadTestApiFp(this.configuration)
      .loadTestCreateJWTs(addressId, id, loadTestCreateJWTsRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * QueryApi - axios parameter creator
 * @export
 */
export const QueryApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @param {string} id
     * @param {string} [addressId]
     * @param {boolean} [includeNodeInfo]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    communityGetCommunity: async (
      id: string,
      addressId?: string,
      includeNodeInfo?: boolean,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('communityGetCommunity', 'id', id);
      const localVarPath = `/GetCommunity`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (id !== undefined) {
        localVarQueryParameter['id'] = id;
      }

      if (includeNodeInfo !== undefined) {
        localVarQueryParameter['include_node_info'] = includeNodeInfo;
      }

      if (addressId != null) {
        localVarHeaderParameter['address_id'] = String(addressId);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} communityId
     * @param {string} [addressId]
     * @param {number | null} [limit]
     * @param {number | null} [cursor] required for tRPC useInfiniteQuery hook, equivalent to page number
     * @param {CommunityGetMembersOrderByEnum} [orderBy]
     * @param {CommunityGetMembersOrderDirectionEnum} [orderDirection]
     * @param {string} [search]
     * @param {boolean} [includeRoles]
     * @param {CommunityGetMembersMembershipsParameter} [memberships]
     * @param {boolean} [includeGroupIds]
     * @param {boolean} [includeStakeBalances]
     * @param {string} [allowedAddresses]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    communityGetMembers: async (
      communityId: string,
      addressId?: string,
      limit?: number | null,
      cursor?: number | null,
      orderBy?: CommunityGetMembersOrderByEnum,
      orderDirection?: CommunityGetMembersOrderDirectionEnum,
      search?: string,
      includeRoles?: boolean,
      memberships?: CommunityGetMembersMembershipsParameter,
      includeGroupIds?: boolean,
      includeStakeBalances?: boolean,
      allowedAddresses?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'communityId' is not null or undefined
      assertParamExists('communityGetMembers', 'communityId', communityId);
      const localVarPath = `/GetMembers`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      if (cursor !== undefined) {
        localVarQueryParameter['cursor'] = cursor;
      }

      if (orderBy !== undefined) {
        localVarQueryParameter['order_by'] = orderBy;
      }

      if (orderDirection !== undefined) {
        localVarQueryParameter['order_direction'] = orderDirection;
      }

      if (search !== undefined) {
        localVarQueryParameter['search'] = search;
      }

      if (communityId !== undefined) {
        localVarQueryParameter['community_id'] = communityId;
      }

      if (includeRoles !== undefined) {
        localVarQueryParameter['include_roles'] = includeRoles;
      }

      if (memberships !== undefined) {
        for (const [key, value] of Object.entries(memberships)) {
          localVarQueryParameter[key] = value;
        }
      }

      if (includeGroupIds !== undefined) {
        localVarQueryParameter['include_group_ids'] = includeGroupIds;
      }

      if (includeStakeBalances !== undefined) {
        localVarQueryParameter['include_stake_balances'] = includeStakeBalances;
      }

      if (allowedAddresses !== undefined) {
        localVarQueryParameter['allowedAddresses'] = allowedAddresses;
      }

      if (addressId != null) {
        localVarHeaderParameter['address_id'] = String(addressId);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} communityId
     * @param {string} [addressId]
     * @param {number} [stakeId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    communityGetStake: async (
      communityId: string,
      addressId?: string,
      stakeId?: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'communityId' is not null or undefined
      assertParamExists('communityGetStake', 'communityId', communityId);
      const localVarPath = `/GetCommunityStake`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (communityId !== undefined) {
        localVarQueryParameter['community_id'] = communityId;
      }

      if (stakeId !== undefined) {
        localVarQueryParameter['stake_id'] = stakeId;
      }

      if (addressId != null) {
        localVarHeaderParameter['address_id'] = String(addressId);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} pastDateEpoch
     * @param {string} [addressId]
     * @param {string} [communityId]
     * @param {number} [stakeId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    communityGetStakeHistoricalPrice: async (
      pastDateEpoch: number,
      addressId?: string,
      communityId?: string,
      stakeId?: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'pastDateEpoch' is not null or undefined
      assertParamExists(
        'communityGetStakeHistoricalPrice',
        'pastDateEpoch',
        pastDateEpoch,
      );
      const localVarPath = `/GetStakeHistoricalPrice`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (pastDateEpoch !== undefined) {
        localVarQueryParameter['past_date_epoch'] = pastDateEpoch;
      }

      if (communityId !== undefined) {
        localVarQueryParameter['community_id'] = communityId;
      }

      if (stakeId !== undefined) {
        localVarQueryParameter['stake_id'] = stakeId;
      }

      if (addressId != null) {
        localVarHeaderParameter['address_id'] = String(addressId);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} [addressId]
     * @param {string} [addresses]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    communityGetStakeTransaction: async (
      addressId?: string,
      addresses?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/GetStakeTransaction`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (addresses !== undefined) {
        localVarQueryParameter['addresses'] = addresses;
      }

      if (addressId != null) {
        localVarHeaderParameter['address_id'] = String(addressId);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} communityId
     * @param {string} [addressId]
     * @param {string} [contestAddress]
     * @param {number} [contestId]
     * @param {boolean} [running]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    contestGetAllContests: async (
      communityId: string,
      addressId?: string,
      contestAddress?: string,
      contestId?: number,
      running?: boolean,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'communityId' is not null or undefined
      assertParamExists('contestGetAllContests', 'communityId', communityId);
      const localVarPath = `/GetAllContests`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (communityId !== undefined) {
        localVarQueryParameter['community_id'] = communityId;
      }

      if (contestAddress !== undefined) {
        localVarQueryParameter['contest_address'] = contestAddress;
      }

      if (contestId !== undefined) {
        localVarQueryParameter['contest_id'] = contestId;
      }

      if (running !== undefined) {
        localVarQueryParameter['running'] = running;
      }

      if (addressId != null) {
        localVarHeaderParameter['address_id'] = String(addressId);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} contestAddress
     * @param {string} [addressId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    contestGetContestLog: async (
      contestAddress: string,
      addressId?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'contestAddress' is not null or undefined
      assertParamExists(
        'contestGetContestLog',
        'contestAddress',
        contestAddress,
      );
      const localVarPath = `/GetContestLog`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (contestAddress !== undefined) {
        localVarQueryParameter['contest_address'] = contestAddress;
      }

      if (addressId != null) {
        localVarHeaderParameter['address_id'] = String(addressId);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} [addressId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    feedGetChainActivity: async (
      addressId?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/GetChainActivity`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (addressId != null) {
        localVarHeaderParameter['address_id'] = String(addressId);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} [addressId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    feedGetGlobalActivity: async (
      addressId?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/GetGlobalActivity`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (addressId != null) {
        localVarHeaderParameter['address_id'] = String(addressId);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} [addressId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    feedGetUserActivity: async (
      addressId?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/GetUserActivity`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (addressId != null) {
        localVarHeaderParameter['address_id'] = String(addressId);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} [addressId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    subscriptionGetCommentSubscriptions: async (
      addressId?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/GetCommentSubscriptions`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (addressId != null) {
        localVarHeaderParameter['address_id'] = String(addressId);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} [addressId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    subscriptionGetCommunityAlerts: async (
      addressId?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/GetCommunityAlerts`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (addressId != null) {
        localVarHeaderParameter['address_id'] = String(addressId);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} [addressId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    subscriptionGetSubscriptionPreferences: async (
      addressId?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/GetSubscriptionPreferences`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (addressId != null) {
        localVarHeaderParameter['address_id'] = String(addressId);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} [addressId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    subscriptionGetThreadSubscriptions: async (
      addressId?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/GetThreadSubscriptions`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (addressId != null) {
        localVarHeaderParameter['address_id'] = String(addressId);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} communityId
     * @param {string} [addressId]
     * @param {string} [fromDate]
     * @param {string} [toDate]
     * @param {boolean} [archived]
     * @param {boolean} [includePinnedThreads]
     * @param {number} [topicId]
     * @param {string} [stage]
     * @param {ThreadGetBulkThreadsOrderByEnum} [orderBy]
     * @param {number} [cursor]
     * @param {number} [limit] The number of objects returned
     * @param {number} [offset] The amount of objects offset from the beginning
     * @param {number} [page] The page returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    threadGetBulkThreads: async (
      communityId: string,
      addressId?: string,
      fromDate?: string,
      toDate?: string,
      archived?: boolean,
      includePinnedThreads?: boolean,
      topicId?: number,
      stage?: string,
      orderBy?: ThreadGetBulkThreadsOrderByEnum,
      cursor?: number,
      limit?: number,
      offset?: number,
      page?: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'communityId' is not null or undefined
      assertParamExists('threadGetBulkThreads', 'communityId', communityId);
      const localVarPath = `/GetBulkThreads`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (communityId !== undefined) {
        localVarQueryParameter['community_id'] = communityId;
      }

      if (fromDate !== undefined) {
        localVarQueryParameter['fromDate'] =
          (fromDate as any) instanceof Date
            ? (fromDate as any).toISOString()
            : fromDate;
      }

      if (toDate !== undefined) {
        localVarQueryParameter['toDate'] =
          (toDate as any) instanceof Date
            ? (toDate as any).toISOString()
            : toDate;
      }

      if (archived !== undefined) {
        localVarQueryParameter['archived'] = archived;
      }

      if (includePinnedThreads !== undefined) {
        localVarQueryParameter['includePinnedThreads'] = includePinnedThreads;
      }

      if (topicId !== undefined) {
        localVarQueryParameter['topicId'] = topicId;
      }

      if (stage !== undefined) {
        localVarQueryParameter['stage'] = stage;
      }

      if (orderBy !== undefined) {
        localVarQueryParameter['orderBy'] = orderBy;
      }

      if (cursor !== undefined) {
        localVarQueryParameter['cursor'] = cursor;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset;
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page;
      }

      if (addressId != null) {
        localVarHeaderParameter['address_id'] = String(addressId);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * QueryApi - functional programming interface
 * @export
 */
export const QueryApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = QueryApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {string} id
     * @param {string} [addressId]
     * @param {boolean} [includeNodeInfo]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async communityGetCommunity(
      id: string,
      addressId?: string,
      includeNodeInfo?: boolean,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<CommunityGetCommunity200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.communityGetCommunity(
          id,
          addressId,
          includeNodeInfo,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['QueryApi.communityGetCommunity']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} communityId
     * @param {string} [addressId]
     * @param {number | null} [limit]
     * @param {number | null} [cursor] required for tRPC useInfiniteQuery hook, equivalent to page number
     * @param {CommunityGetMembersOrderByEnum} [orderBy]
     * @param {CommunityGetMembersOrderDirectionEnum} [orderDirection]
     * @param {string} [search]
     * @param {boolean} [includeRoles]
     * @param {CommunityGetMembersMembershipsParameter} [memberships]
     * @param {boolean} [includeGroupIds]
     * @param {boolean} [includeStakeBalances]
     * @param {string} [allowedAddresses]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async communityGetMembers(
      communityId: string,
      addressId?: string,
      limit?: number | null,
      cursor?: number | null,
      orderBy?: CommunityGetMembersOrderByEnum,
      orderDirection?: CommunityGetMembersOrderDirectionEnum,
      search?: string,
      includeRoles?: boolean,
      memberships?: CommunityGetMembersMembershipsParameter,
      includeGroupIds?: boolean,
      includeStakeBalances?: boolean,
      allowedAddresses?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<CommunityGetMembers200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.communityGetMembers(
          communityId,
          addressId,
          limit,
          cursor,
          orderBy,
          orderDirection,
          search,
          includeRoles,
          memberships,
          includeGroupIds,
          includeStakeBalances,
          allowedAddresses,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['QueryApi.communityGetMembers']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} communityId
     * @param {string} [addressId]
     * @param {number} [stakeId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async communityGetStake(
      communityId: string,
      addressId?: string,
      stakeId?: number,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<CommunityGetStake200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.communityGetStake(
          communityId,
          addressId,
          stakeId,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['QueryApi.communityGetStake']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {number} pastDateEpoch
     * @param {string} [addressId]
     * @param {string} [communityId]
     * @param {number} [stakeId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async communityGetStakeHistoricalPrice(
      pastDateEpoch: number,
      addressId?: string,
      communityId?: string,
      stakeId?: number,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<CommunityGetStakeHistoricalPrice200ResponseInner>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.communityGetStakeHistoricalPrice(
          pastDateEpoch,
          addressId,
          communityId,
          stakeId,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['QueryApi.communityGetStakeHistoricalPrice']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} [addressId]
     * @param {string} [addresses]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async communityGetStakeTransaction(
      addressId?: string,
      addresses?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<CommunityGetStakeTransaction200ResponseInner>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.communityGetStakeTransaction(
          addressId,
          addresses,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['QueryApi.communityGetStakeTransaction']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} communityId
     * @param {string} [addressId]
     * @param {string} [contestAddress]
     * @param {number} [contestId]
     * @param {boolean} [running]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async contestGetAllContests(
      communityId: string,
      addressId?: string,
      contestAddress?: string,
      contestId?: number,
      running?: boolean,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<ContestGetAllContests200ResponseInner>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.contestGetAllContests(
          communityId,
          addressId,
          contestAddress,
          contestId,
          running,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['QueryApi.contestGetAllContests']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} contestAddress
     * @param {string} [addressId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async contestGetContestLog(
      contestAddress: string,
      addressId?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<ContestGetContestLog200ResponseInner>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.contestGetContestLog(
          contestAddress,
          addressId,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['QueryApi.contestGetContestLog']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} [addressId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async feedGetChainActivity(
      addressId?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<FeedGetChainActivity200ResponseInner>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.feedGetChainActivity(
          addressId,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['QueryApi.feedGetChainActivity']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} [addressId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async feedGetGlobalActivity(
      addressId?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<FeedGetUserActivity200ResponseInner>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.feedGetGlobalActivity(
          addressId,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['QueryApi.feedGetGlobalActivity']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} [addressId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async feedGetUserActivity(
      addressId?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<FeedGetUserActivity200ResponseInner>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.feedGetUserActivity(addressId, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['QueryApi.feedGetUserActivity']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} [addressId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async subscriptionGetCommentSubscriptions(
      addressId?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<SubscriptionCreateCommentSubscription200Response>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.subscriptionGetCommentSubscriptions(
          addressId,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['QueryApi.subscriptionGetCommentSubscriptions']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} [addressId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async subscriptionGetCommunityAlerts(
      addressId?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<SubscriptionCreateCommunityAlert200Response>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.subscriptionGetCommunityAlerts(
          addressId,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['QueryApi.subscriptionGetCommunityAlerts']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} [addressId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async subscriptionGetSubscriptionPreferences(
      addressId?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SubscriptionGetSubscriptionPreferences200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.subscriptionGetSubscriptionPreferences(
          addressId,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['QueryApi.subscriptionGetSubscriptionPreferences']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} [addressId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async subscriptionGetThreadSubscriptions(
      addressId?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<SubscriptionCreateThreadSubscription200Response>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.subscriptionGetThreadSubscriptions(
          addressId,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['QueryApi.subscriptionGetThreadSubscriptions']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} communityId
     * @param {string} [addressId]
     * @param {string} [fromDate]
     * @param {string} [toDate]
     * @param {boolean} [archived]
     * @param {boolean} [includePinnedThreads]
     * @param {number} [topicId]
     * @param {string} [stage]
     * @param {ThreadGetBulkThreadsOrderByEnum} [orderBy]
     * @param {number} [cursor]
     * @param {number} [limit] The number of objects returned
     * @param {number} [offset] The amount of objects offset from the beginning
     * @param {number} [page] The page returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async threadGetBulkThreads(
      communityId: string,
      addressId?: string,
      fromDate?: string,
      toDate?: string,
      archived?: boolean,
      includePinnedThreads?: boolean,
      topicId?: number,
      stage?: string,
      orderBy?: ThreadGetBulkThreadsOrderByEnum,
      cursor?: number,
      limit?: number,
      offset?: number,
      page?: number,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ThreadGetBulkThreads200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.threadGetBulkThreads(
          communityId,
          addressId,
          fromDate,
          toDate,
          archived,
          includePinnedThreads,
          topicId,
          stage,
          orderBy,
          cursor,
          limit,
          offset,
          page,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['QueryApi.threadGetBulkThreads']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * QueryApi - factory interface
 * @export
 */
export const QueryApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = QueryApiFp(configuration);
  return {
    /**
     *
     * @param {string} id
     * @param {string} [addressId]
     * @param {boolean} [includeNodeInfo]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    communityGetCommunity(
      id: string,
      addressId?: string,
      includeNodeInfo?: boolean,
      options?: any,
    ): AxiosPromise<CommunityGetCommunity200Response> {
      return localVarFp
        .communityGetCommunity(id, addressId, includeNodeInfo, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} communityId
     * @param {string} [addressId]
     * @param {number | null} [limit]
     * @param {number | null} [cursor] required for tRPC useInfiniteQuery hook, equivalent to page number
     * @param {CommunityGetMembersOrderByEnum} [orderBy]
     * @param {CommunityGetMembersOrderDirectionEnum} [orderDirection]
     * @param {string} [search]
     * @param {boolean} [includeRoles]
     * @param {CommunityGetMembersMembershipsParameter} [memberships]
     * @param {boolean} [includeGroupIds]
     * @param {boolean} [includeStakeBalances]
     * @param {string} [allowedAddresses]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    communityGetMembers(
      communityId: string,
      addressId?: string,
      limit?: number | null,
      cursor?: number | null,
      orderBy?: CommunityGetMembersOrderByEnum,
      orderDirection?: CommunityGetMembersOrderDirectionEnum,
      search?: string,
      includeRoles?: boolean,
      memberships?: CommunityGetMembersMembershipsParameter,
      includeGroupIds?: boolean,
      includeStakeBalances?: boolean,
      allowedAddresses?: string,
      options?: any,
    ): AxiosPromise<CommunityGetMembers200Response> {
      return localVarFp
        .communityGetMembers(
          communityId,
          addressId,
          limit,
          cursor,
          orderBy,
          orderDirection,
          search,
          includeRoles,
          memberships,
          includeGroupIds,
          includeStakeBalances,
          allowedAddresses,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} communityId
     * @param {string} [addressId]
     * @param {number} [stakeId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    communityGetStake(
      communityId: string,
      addressId?: string,
      stakeId?: number,
      options?: any,
    ): AxiosPromise<CommunityGetStake200Response> {
      return localVarFp
        .communityGetStake(communityId, addressId, stakeId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {number} pastDateEpoch
     * @param {string} [addressId]
     * @param {string} [communityId]
     * @param {number} [stakeId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    communityGetStakeHistoricalPrice(
      pastDateEpoch: number,
      addressId?: string,
      communityId?: string,
      stakeId?: number,
      options?: any,
    ): AxiosPromise<Array<CommunityGetStakeHistoricalPrice200ResponseInner>> {
      return localVarFp
        .communityGetStakeHistoricalPrice(
          pastDateEpoch,
          addressId,
          communityId,
          stakeId,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} [addressId]
     * @param {string} [addresses]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    communityGetStakeTransaction(
      addressId?: string,
      addresses?: string,
      options?: any,
    ): AxiosPromise<Array<CommunityGetStakeTransaction200ResponseInner>> {
      return localVarFp
        .communityGetStakeTransaction(addressId, addresses, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} communityId
     * @param {string} [addressId]
     * @param {string} [contestAddress]
     * @param {number} [contestId]
     * @param {boolean} [running]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    contestGetAllContests(
      communityId: string,
      addressId?: string,
      contestAddress?: string,
      contestId?: number,
      running?: boolean,
      options?: any,
    ): AxiosPromise<Array<ContestGetAllContests200ResponseInner>> {
      return localVarFp
        .contestGetAllContests(
          communityId,
          addressId,
          contestAddress,
          contestId,
          running,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} contestAddress
     * @param {string} [addressId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    contestGetContestLog(
      contestAddress: string,
      addressId?: string,
      options?: any,
    ): AxiosPromise<Array<ContestGetContestLog200ResponseInner>> {
      return localVarFp
        .contestGetContestLog(contestAddress, addressId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} [addressId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    feedGetChainActivity(
      addressId?: string,
      options?: any,
    ): AxiosPromise<Array<FeedGetChainActivity200ResponseInner>> {
      return localVarFp
        .feedGetChainActivity(addressId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} [addressId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    feedGetGlobalActivity(
      addressId?: string,
      options?: any,
    ): AxiosPromise<Array<FeedGetUserActivity200ResponseInner>> {
      return localVarFp
        .feedGetGlobalActivity(addressId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} [addressId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    feedGetUserActivity(
      addressId?: string,
      options?: any,
    ): AxiosPromise<Array<FeedGetUserActivity200ResponseInner>> {
      return localVarFp
        .feedGetUserActivity(addressId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} [addressId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    subscriptionGetCommentSubscriptions(
      addressId?: string,
      options?: any,
    ): AxiosPromise<Array<SubscriptionCreateCommentSubscription200Response>> {
      return localVarFp
        .subscriptionGetCommentSubscriptions(addressId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} [addressId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    subscriptionGetCommunityAlerts(
      addressId?: string,
      options?: any,
    ): AxiosPromise<Array<SubscriptionCreateCommunityAlert200Response>> {
      return localVarFp
        .subscriptionGetCommunityAlerts(addressId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} [addressId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    subscriptionGetSubscriptionPreferences(
      addressId?: string,
      options?: any,
    ): AxiosPromise<SubscriptionGetSubscriptionPreferences200Response> {
      return localVarFp
        .subscriptionGetSubscriptionPreferences(addressId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} [addressId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    subscriptionGetThreadSubscriptions(
      addressId?: string,
      options?: any,
    ): AxiosPromise<Array<SubscriptionCreateThreadSubscription200Response>> {
      return localVarFp
        .subscriptionGetThreadSubscriptions(addressId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} communityId
     * @param {string} [addressId]
     * @param {string} [fromDate]
     * @param {string} [toDate]
     * @param {boolean} [archived]
     * @param {boolean} [includePinnedThreads]
     * @param {number} [topicId]
     * @param {string} [stage]
     * @param {ThreadGetBulkThreadsOrderByEnum} [orderBy]
     * @param {number} [cursor]
     * @param {number} [limit] The number of objects returned
     * @param {number} [offset] The amount of objects offset from the beginning
     * @param {number} [page] The page returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    threadGetBulkThreads(
      communityId: string,
      addressId?: string,
      fromDate?: string,
      toDate?: string,
      archived?: boolean,
      includePinnedThreads?: boolean,
      topicId?: number,
      stage?: string,
      orderBy?: ThreadGetBulkThreadsOrderByEnum,
      cursor?: number,
      limit?: number,
      offset?: number,
      page?: number,
      options?: any,
    ): AxiosPromise<ThreadGetBulkThreads200Response> {
      return localVarFp
        .threadGetBulkThreads(
          communityId,
          addressId,
          fromDate,
          toDate,
          archived,
          includePinnedThreads,
          topicId,
          stage,
          orderBy,
          cursor,
          limit,
          offset,
          page,
          options,
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * QueryApi - object-oriented interface
 * @export
 * @class QueryApi
 * @extends {BaseAPI}
 */
export class QueryApi extends BaseAPI {
  /**
   *
   * @param {string} id
   * @param {string} [addressId]
   * @param {boolean} [includeNodeInfo]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public communityGetCommunity(
    id: string,
    addressId?: string,
    includeNodeInfo?: boolean,
    options?: RawAxiosRequestConfig,
  ) {
    return QueryApiFp(this.configuration)
      .communityGetCommunity(id, addressId, includeNodeInfo, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} communityId
   * @param {string} [addressId]
   * @param {number | null} [limit]
   * @param {number | null} [cursor] required for tRPC useInfiniteQuery hook, equivalent to page number
   * @param {CommunityGetMembersOrderByEnum} [orderBy]
   * @param {CommunityGetMembersOrderDirectionEnum} [orderDirection]
   * @param {string} [search]
   * @param {boolean} [includeRoles]
   * @param {CommunityGetMembersMembershipsParameter} [memberships]
   * @param {boolean} [includeGroupIds]
   * @param {boolean} [includeStakeBalances]
   * @param {string} [allowedAddresses]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public communityGetMembers(
    communityId: string,
    addressId?: string,
    limit?: number | null,
    cursor?: number | null,
    orderBy?: CommunityGetMembersOrderByEnum,
    orderDirection?: CommunityGetMembersOrderDirectionEnum,
    search?: string,
    includeRoles?: boolean,
    memberships?: CommunityGetMembersMembershipsParameter,
    includeGroupIds?: boolean,
    includeStakeBalances?: boolean,
    allowedAddresses?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return QueryApiFp(this.configuration)
      .communityGetMembers(
        communityId,
        addressId,
        limit,
        cursor,
        orderBy,
        orderDirection,
        search,
        includeRoles,
        memberships,
        includeGroupIds,
        includeStakeBalances,
        allowedAddresses,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} communityId
   * @param {string} [addressId]
   * @param {number} [stakeId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public communityGetStake(
    communityId: string,
    addressId?: string,
    stakeId?: number,
    options?: RawAxiosRequestConfig,
  ) {
    return QueryApiFp(this.configuration)
      .communityGetStake(communityId, addressId, stakeId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} pastDateEpoch
   * @param {string} [addressId]
   * @param {string} [communityId]
   * @param {number} [stakeId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public communityGetStakeHistoricalPrice(
    pastDateEpoch: number,
    addressId?: string,
    communityId?: string,
    stakeId?: number,
    options?: RawAxiosRequestConfig,
  ) {
    return QueryApiFp(this.configuration)
      .communityGetStakeHistoricalPrice(
        pastDateEpoch,
        addressId,
        communityId,
        stakeId,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} [addressId]
   * @param {string} [addresses]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public communityGetStakeTransaction(
    addressId?: string,
    addresses?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return QueryApiFp(this.configuration)
      .communityGetStakeTransaction(addressId, addresses, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} communityId
   * @param {string} [addressId]
   * @param {string} [contestAddress]
   * @param {number} [contestId]
   * @param {boolean} [running]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public contestGetAllContests(
    communityId: string,
    addressId?: string,
    contestAddress?: string,
    contestId?: number,
    running?: boolean,
    options?: RawAxiosRequestConfig,
  ) {
    return QueryApiFp(this.configuration)
      .contestGetAllContests(
        communityId,
        addressId,
        contestAddress,
        contestId,
        running,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} contestAddress
   * @param {string} [addressId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public contestGetContestLog(
    contestAddress: string,
    addressId?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return QueryApiFp(this.configuration)
      .contestGetContestLog(contestAddress, addressId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} [addressId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public feedGetChainActivity(
    addressId?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return QueryApiFp(this.configuration)
      .feedGetChainActivity(addressId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} [addressId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public feedGetGlobalActivity(
    addressId?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return QueryApiFp(this.configuration)
      .feedGetGlobalActivity(addressId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} [addressId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public feedGetUserActivity(
    addressId?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return QueryApiFp(this.configuration)
      .feedGetUserActivity(addressId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} [addressId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public subscriptionGetCommentSubscriptions(
    addressId?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return QueryApiFp(this.configuration)
      .subscriptionGetCommentSubscriptions(addressId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} [addressId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public subscriptionGetCommunityAlerts(
    addressId?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return QueryApiFp(this.configuration)
      .subscriptionGetCommunityAlerts(addressId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} [addressId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public subscriptionGetSubscriptionPreferences(
    addressId?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return QueryApiFp(this.configuration)
      .subscriptionGetSubscriptionPreferences(addressId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} [addressId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public subscriptionGetThreadSubscriptions(
    addressId?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return QueryApiFp(this.configuration)
      .subscriptionGetThreadSubscriptions(addressId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} communityId
   * @param {string} [addressId]
   * @param {string} [fromDate]
   * @param {string} [toDate]
   * @param {boolean} [archived]
   * @param {boolean} [includePinnedThreads]
   * @param {number} [topicId]
   * @param {string} [stage]
   * @param {ThreadGetBulkThreadsOrderByEnum} [orderBy]
   * @param {number} [cursor]
   * @param {number} [limit] The number of objects returned
   * @param {number} [offset] The amount of objects offset from the beginning
   * @param {number} [page] The page returned
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueryApi
   */
  public threadGetBulkThreads(
    communityId: string,
    addressId?: string,
    fromDate?: string,
    toDate?: string,
    archived?: boolean,
    includePinnedThreads?: boolean,
    topicId?: number,
    stage?: string,
    orderBy?: ThreadGetBulkThreadsOrderByEnum,
    cursor?: number,
    limit?: number,
    offset?: number,
    page?: number,
    options?: RawAxiosRequestConfig,
  ) {
    return QueryApiFp(this.configuration)
      .threadGetBulkThreads(
        communityId,
        addressId,
        fromDate,
        toDate,
        archived,
        includePinnedThreads,
        topicId,
        stage,
        orderBy,
        cursor,
        limit,
        offset,
        page,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * @export
 */
export const CommunityGetMembersOrderByEnum = {
  LastActive: 'last_active',
  Name: 'name',
} as const;
export type CommunityGetMembersOrderByEnum =
  typeof CommunityGetMembersOrderByEnum[keyof typeof CommunityGetMembersOrderByEnum];
/**
 * @export
 */
export const CommunityGetMembersOrderDirectionEnum = {
  Asc: 'ASC',
  Desc: 'DESC',
} as const;
export type CommunityGetMembersOrderDirectionEnum =
  typeof CommunityGetMembersOrderDirectionEnum[keyof typeof CommunityGetMembersOrderDirectionEnum];
/**
 * @export
 */
export const ThreadGetBulkThreadsOrderByEnum = {
  CreatedAtasc: 'createdAt:asc',
  CreatedAtdesc: 'createdAt:desc',
  NumberOfCommentsasc: 'numberOfComments:asc',
  NumberOfCommentsdesc: 'numberOfComments:desc',
  NumberOfLikesasc: 'numberOfLikes:asc',
  NumberOfLikesdesc: 'numberOfLikes:desc',
  LatestActivityasc: 'latestActivity:asc',
  LatestActivitydesc: 'latestActivity:desc',
} as const;
export type ThreadGetBulkThreadsOrderByEnum =
  typeof ThreadGetBulkThreadsOrderByEnum[keyof typeof ThreadGetBulkThreadsOrderByEnum];

/**
 * SubscriptionApi - axios parameter creator
 * @export
 */
export const SubscriptionApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @param {string} addressId
     * @param {number} id
     * @param {SubscriptionCreateCommentSubscriptionRequest} subscriptionCreateCommentSubscriptionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    subscriptionCreateCommentSubscription: async (
      addressId: string,
      id: number,
      subscriptionCreateCommentSubscriptionRequest: SubscriptionCreateCommentSubscriptionRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'addressId' is not null or undefined
      assertParamExists(
        'subscriptionCreateCommentSubscription',
        'addressId',
        addressId,
      );
      // verify required parameter 'id' is not null or undefined
      assertParamExists('subscriptionCreateCommentSubscription', 'id', id);
      // verify required parameter 'subscriptionCreateCommentSubscriptionRequest' is not null or undefined
      assertParamExists(
        'subscriptionCreateCommentSubscription',
        'subscriptionCreateCommentSubscriptionRequest',
        subscriptionCreateCommentSubscriptionRequest,
      );
      const localVarPath = `/CreateCommentSubscription/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'oauth2',
        [],
        configuration,
      );

      if (addressId != null) {
        localVarHeaderParameter['address_id'] = String(addressId);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        subscriptionCreateCommentSubscriptionRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} addressId
     * @param {number} id
     * @param {SubscriptionCreateCommunityAlertRequest} subscriptionCreateCommunityAlertRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    subscriptionCreateCommunityAlert: async (
      addressId: string,
      id: number,
      subscriptionCreateCommunityAlertRequest: SubscriptionCreateCommunityAlertRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'addressId' is not null or undefined
      assertParamExists(
        'subscriptionCreateCommunityAlert',
        'addressId',
        addressId,
      );
      // verify required parameter 'id' is not null or undefined
      assertParamExists('subscriptionCreateCommunityAlert', 'id', id);
      // verify required parameter 'subscriptionCreateCommunityAlertRequest' is not null or undefined
      assertParamExists(
        'subscriptionCreateCommunityAlert',
        'subscriptionCreateCommunityAlertRequest',
        subscriptionCreateCommunityAlertRequest,
      );
      const localVarPath = `/CreateCommunityAlert/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'oauth2',
        [],
        configuration,
      );

      if (addressId != null) {
        localVarHeaderParameter['address_id'] = String(addressId);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        subscriptionCreateCommunityAlertRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} addressId
     * @param {number} id
     * @param {SubscriptionCreateThreadSubscriptionRequest} subscriptionCreateThreadSubscriptionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    subscriptionCreateThreadSubscription: async (
      addressId: string,
      id: number,
      subscriptionCreateThreadSubscriptionRequest: SubscriptionCreateThreadSubscriptionRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'addressId' is not null or undefined
      assertParamExists(
        'subscriptionCreateThreadSubscription',
        'addressId',
        addressId,
      );
      // verify required parameter 'id' is not null or undefined
      assertParamExists('subscriptionCreateThreadSubscription', 'id', id);
      // verify required parameter 'subscriptionCreateThreadSubscriptionRequest' is not null or undefined
      assertParamExists(
        'subscriptionCreateThreadSubscription',
        'subscriptionCreateThreadSubscriptionRequest',
        subscriptionCreateThreadSubscriptionRequest,
      );
      const localVarPath = `/CreateThreadSubscription/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'oauth2',
        [],
        configuration,
      );

      if (addressId != null) {
        localVarHeaderParameter['address_id'] = String(addressId);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        subscriptionCreateThreadSubscriptionRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} addressId
     * @param {number} id
     * @param {SubscriptionDeleteCommentSubscriptionRequest} subscriptionDeleteCommentSubscriptionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    subscriptionDeleteCommentSubscription: async (
      addressId: string,
      id: number,
      subscriptionDeleteCommentSubscriptionRequest: SubscriptionDeleteCommentSubscriptionRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'addressId' is not null or undefined
      assertParamExists(
        'subscriptionDeleteCommentSubscription',
        'addressId',
        addressId,
      );
      // verify required parameter 'id' is not null or undefined
      assertParamExists('subscriptionDeleteCommentSubscription', 'id', id);
      // verify required parameter 'subscriptionDeleteCommentSubscriptionRequest' is not null or undefined
      assertParamExists(
        'subscriptionDeleteCommentSubscription',
        'subscriptionDeleteCommentSubscriptionRequest',
        subscriptionDeleteCommentSubscriptionRequest,
      );
      const localVarPath = `/DeleteCommentSubscription/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'oauth2',
        [],
        configuration,
      );

      if (addressId != null) {
        localVarHeaderParameter['address_id'] = String(addressId);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        subscriptionDeleteCommentSubscriptionRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} addressId
     * @param {number} id
     * @param {SubscriptionDeleteCommunityAlertRequest} subscriptionDeleteCommunityAlertRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    subscriptionDeleteCommunityAlert: async (
      addressId: string,
      id: number,
      subscriptionDeleteCommunityAlertRequest: SubscriptionDeleteCommunityAlertRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'addressId' is not null or undefined
      assertParamExists(
        'subscriptionDeleteCommunityAlert',
        'addressId',
        addressId,
      );
      // verify required parameter 'id' is not null or undefined
      assertParamExists('subscriptionDeleteCommunityAlert', 'id', id);
      // verify required parameter 'subscriptionDeleteCommunityAlertRequest' is not null or undefined
      assertParamExists(
        'subscriptionDeleteCommunityAlert',
        'subscriptionDeleteCommunityAlertRequest',
        subscriptionDeleteCommunityAlertRequest,
      );
      const localVarPath = `/DeleteCommunityAlerts/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'oauth2',
        [],
        configuration,
      );

      if (addressId != null) {
        localVarHeaderParameter['address_id'] = String(addressId);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        subscriptionDeleteCommunityAlertRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} addressId
     * @param {number} id
     * @param {SubscriptionDeleteThreadSubscriptionRequest} subscriptionDeleteThreadSubscriptionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    subscriptionDeleteThreadSubscription: async (
      addressId: string,
      id: number,
      subscriptionDeleteThreadSubscriptionRequest: SubscriptionDeleteThreadSubscriptionRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'addressId' is not null or undefined
      assertParamExists(
        'subscriptionDeleteThreadSubscription',
        'addressId',
        addressId,
      );
      // verify required parameter 'id' is not null or undefined
      assertParamExists('subscriptionDeleteThreadSubscription', 'id', id);
      // verify required parameter 'subscriptionDeleteThreadSubscriptionRequest' is not null or undefined
      assertParamExists(
        'subscriptionDeleteThreadSubscription',
        'subscriptionDeleteThreadSubscriptionRequest',
        subscriptionDeleteThreadSubscriptionRequest,
      );
      const localVarPath = `/DeleteThreadSubscription/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'oauth2',
        [],
        configuration,
      );

      if (addressId != null) {
        localVarHeaderParameter['address_id'] = String(addressId);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        subscriptionDeleteThreadSubscriptionRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} addressId
     * @param {number} id
     * @param {SubscriptionRegisterClientRegistrationTokenRequest} subscriptionRegisterClientRegistrationTokenRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    subscriptionRegisterClientRegistrationToken: async (
      addressId: string,
      id: number,
      subscriptionRegisterClientRegistrationTokenRequest: SubscriptionRegisterClientRegistrationTokenRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'addressId' is not null or undefined
      assertParamExists(
        'subscriptionRegisterClientRegistrationToken',
        'addressId',
        addressId,
      );
      // verify required parameter 'id' is not null or undefined
      assertParamExists(
        'subscriptionRegisterClientRegistrationToken',
        'id',
        id,
      );
      // verify required parameter 'subscriptionRegisterClientRegistrationTokenRequest' is not null or undefined
      assertParamExists(
        'subscriptionRegisterClientRegistrationToken',
        'subscriptionRegisterClientRegistrationTokenRequest',
        subscriptionRegisterClientRegistrationTokenRequest,
      );
      const localVarPath = `/RegisterClientRegistrationToken/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'oauth2',
        [],
        configuration,
      );

      if (addressId != null) {
        localVarHeaderParameter['address_id'] = String(addressId);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        subscriptionRegisterClientRegistrationTokenRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} addressId
     * @param {number} id
     * @param {SubscriptionRegisterClientRegistrationTokenRequest} subscriptionRegisterClientRegistrationTokenRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    subscriptionUnregisterClientRegistrationToken: async (
      addressId: string,
      id: number,
      subscriptionRegisterClientRegistrationTokenRequest: SubscriptionRegisterClientRegistrationTokenRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'addressId' is not null or undefined
      assertParamExists(
        'subscriptionUnregisterClientRegistrationToken',
        'addressId',
        addressId,
      );
      // verify required parameter 'id' is not null or undefined
      assertParamExists(
        'subscriptionUnregisterClientRegistrationToken',
        'id',
        id,
      );
      // verify required parameter 'subscriptionRegisterClientRegistrationTokenRequest' is not null or undefined
      assertParamExists(
        'subscriptionUnregisterClientRegistrationToken',
        'subscriptionRegisterClientRegistrationTokenRequest',
        subscriptionRegisterClientRegistrationTokenRequest,
      );
      const localVarPath = `/UnregisterClientRegistrationToken/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'oauth2',
        [],
        configuration,
      );

      if (addressId != null) {
        localVarHeaderParameter['address_id'] = String(addressId);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        subscriptionRegisterClientRegistrationTokenRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} addressId
     * @param {number} id
     * @param {SubscriptionUpdateSubscriptionPreferencesRequest} subscriptionUpdateSubscriptionPreferencesRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    subscriptionUpdateSubscriptionPreferences: async (
      addressId: string,
      id: number,
      subscriptionUpdateSubscriptionPreferencesRequest: SubscriptionUpdateSubscriptionPreferencesRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'addressId' is not null or undefined
      assertParamExists(
        'subscriptionUpdateSubscriptionPreferences',
        'addressId',
        addressId,
      );
      // verify required parameter 'id' is not null or undefined
      assertParamExists('subscriptionUpdateSubscriptionPreferences', 'id', id);
      // verify required parameter 'subscriptionUpdateSubscriptionPreferencesRequest' is not null or undefined
      assertParamExists(
        'subscriptionUpdateSubscriptionPreferences',
        'subscriptionUpdateSubscriptionPreferencesRequest',
        subscriptionUpdateSubscriptionPreferencesRequest,
      );
      const localVarPath = `/UpdateSubscriptionPreferences/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication oauth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'oauth2',
        [],
        configuration,
      );

      if (addressId != null) {
        localVarHeaderParameter['address_id'] = String(addressId);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        subscriptionUpdateSubscriptionPreferencesRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SubscriptionApi - functional programming interface
 * @export
 */
export const SubscriptionApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    SubscriptionApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {string} addressId
     * @param {number} id
     * @param {SubscriptionCreateCommentSubscriptionRequest} subscriptionCreateCommentSubscriptionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async subscriptionCreateCommentSubscription(
      addressId: string,
      id: number,
      subscriptionCreateCommentSubscriptionRequest: SubscriptionCreateCommentSubscriptionRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SubscriptionCreateCommentSubscription200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.subscriptionCreateCommentSubscription(
          addressId,
          id,
          subscriptionCreateCommentSubscriptionRequest,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap[
          'SubscriptionApi.subscriptionCreateCommentSubscription'
        ]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} addressId
     * @param {number} id
     * @param {SubscriptionCreateCommunityAlertRequest} subscriptionCreateCommunityAlertRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async subscriptionCreateCommunityAlert(
      addressId: string,
      id: number,
      subscriptionCreateCommunityAlertRequest: SubscriptionCreateCommunityAlertRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SubscriptionCreateCommunityAlert200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.subscriptionCreateCommunityAlert(
          addressId,
          id,
          subscriptionCreateCommunityAlertRequest,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap[
          'SubscriptionApi.subscriptionCreateCommunityAlert'
        ]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} addressId
     * @param {number} id
     * @param {SubscriptionCreateThreadSubscriptionRequest} subscriptionCreateThreadSubscriptionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async subscriptionCreateThreadSubscription(
      addressId: string,
      id: number,
      subscriptionCreateThreadSubscriptionRequest: SubscriptionCreateThreadSubscriptionRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SubscriptionCreateThreadSubscription200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.subscriptionCreateThreadSubscription(
          addressId,
          id,
          subscriptionCreateThreadSubscriptionRequest,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap[
          'SubscriptionApi.subscriptionCreateThreadSubscription'
        ]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} addressId
     * @param {number} id
     * @param {SubscriptionDeleteCommentSubscriptionRequest} subscriptionDeleteCommentSubscriptionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async subscriptionDeleteCommentSubscription(
      addressId: string,
      id: number,
      subscriptionDeleteCommentSubscriptionRequest: SubscriptionDeleteCommentSubscriptionRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.subscriptionDeleteCommentSubscription(
          addressId,
          id,
          subscriptionDeleteCommentSubscriptionRequest,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap[
          'SubscriptionApi.subscriptionDeleteCommentSubscription'
        ]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} addressId
     * @param {number} id
     * @param {SubscriptionDeleteCommunityAlertRequest} subscriptionDeleteCommunityAlertRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async subscriptionDeleteCommunityAlert(
      addressId: string,
      id: number,
      subscriptionDeleteCommunityAlertRequest: SubscriptionDeleteCommunityAlertRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.subscriptionDeleteCommunityAlert(
          addressId,
          id,
          subscriptionDeleteCommunityAlertRequest,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap[
          'SubscriptionApi.subscriptionDeleteCommunityAlert'
        ]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} addressId
     * @param {number} id
     * @param {SubscriptionDeleteThreadSubscriptionRequest} subscriptionDeleteThreadSubscriptionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async subscriptionDeleteThreadSubscription(
      addressId: string,
      id: number,
      subscriptionDeleteThreadSubscriptionRequest: SubscriptionDeleteThreadSubscriptionRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.subscriptionDeleteThreadSubscription(
          addressId,
          id,
          subscriptionDeleteThreadSubscriptionRequest,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap[
          'SubscriptionApi.subscriptionDeleteThreadSubscription'
        ]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} addressId
     * @param {number} id
     * @param {SubscriptionRegisterClientRegistrationTokenRequest} subscriptionRegisterClientRegistrationTokenRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async subscriptionRegisterClientRegistrationToken(
      addressId: string,
      id: number,
      subscriptionRegisterClientRegistrationTokenRequest: SubscriptionRegisterClientRegistrationTokenRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.subscriptionRegisterClientRegistrationToken(
          addressId,
          id,
          subscriptionRegisterClientRegistrationTokenRequest,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap[
          'SubscriptionApi.subscriptionRegisterClientRegistrationToken'
        ]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} addressId
     * @param {number} id
     * @param {SubscriptionRegisterClientRegistrationTokenRequest} subscriptionRegisterClientRegistrationTokenRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async subscriptionUnregisterClientRegistrationToken(
      addressId: string,
      id: number,
      subscriptionRegisterClientRegistrationTokenRequest: SubscriptionRegisterClientRegistrationTokenRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.subscriptionUnregisterClientRegistrationToken(
          addressId,
          id,
          subscriptionRegisterClientRegistrationTokenRequest,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap[
          'SubscriptionApi.subscriptionUnregisterClientRegistrationToken'
        ]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {string} addressId
     * @param {number} id
     * @param {SubscriptionUpdateSubscriptionPreferencesRequest} subscriptionUpdateSubscriptionPreferencesRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async subscriptionUpdateSubscriptionPreferences(
      addressId: string,
      id: number,
      subscriptionUpdateSubscriptionPreferencesRequest: SubscriptionUpdateSubscriptionPreferencesRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SubscriptionGetSubscriptionPreferences200ResponseAnyOf>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.subscriptionUpdateSubscriptionPreferences(
          addressId,
          id,
          subscriptionUpdateSubscriptionPreferencesRequest,
          options,
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap[
          'SubscriptionApi.subscriptionUpdateSubscriptionPreferences'
        ]?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * SubscriptionApi - factory interface
 * @export
 */
export const SubscriptionApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = SubscriptionApiFp(configuration);
  return {
    /**
     *
     * @param {string} addressId
     * @param {number} id
     * @param {SubscriptionCreateCommentSubscriptionRequest} subscriptionCreateCommentSubscriptionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    subscriptionCreateCommentSubscription(
      addressId: string,
      id: number,
      subscriptionCreateCommentSubscriptionRequest: SubscriptionCreateCommentSubscriptionRequest,
      options?: any,
    ): AxiosPromise<SubscriptionCreateCommentSubscription200Response> {
      return localVarFp
        .subscriptionCreateCommentSubscription(
          addressId,
          id,
          subscriptionCreateCommentSubscriptionRequest,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} addressId
     * @param {number} id
     * @param {SubscriptionCreateCommunityAlertRequest} subscriptionCreateCommunityAlertRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    subscriptionCreateCommunityAlert(
      addressId: string,
      id: number,
      subscriptionCreateCommunityAlertRequest: SubscriptionCreateCommunityAlertRequest,
      options?: any,
    ): AxiosPromise<SubscriptionCreateCommunityAlert200Response> {
      return localVarFp
        .subscriptionCreateCommunityAlert(
          addressId,
          id,
          subscriptionCreateCommunityAlertRequest,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} addressId
     * @param {number} id
     * @param {SubscriptionCreateThreadSubscriptionRequest} subscriptionCreateThreadSubscriptionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    subscriptionCreateThreadSubscription(
      addressId: string,
      id: number,
      subscriptionCreateThreadSubscriptionRequest: SubscriptionCreateThreadSubscriptionRequest,
      options?: any,
    ): AxiosPromise<SubscriptionCreateThreadSubscription200Response> {
      return localVarFp
        .subscriptionCreateThreadSubscription(
          addressId,
          id,
          subscriptionCreateThreadSubscriptionRequest,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} addressId
     * @param {number} id
     * @param {SubscriptionDeleteCommentSubscriptionRequest} subscriptionDeleteCommentSubscriptionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    subscriptionDeleteCommentSubscription(
      addressId: string,
      id: number,
      subscriptionDeleteCommentSubscriptionRequest: SubscriptionDeleteCommentSubscriptionRequest,
      options?: any,
    ): AxiosPromise<number> {
      return localVarFp
        .subscriptionDeleteCommentSubscription(
          addressId,
          id,
          subscriptionDeleteCommentSubscriptionRequest,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} addressId
     * @param {number} id
     * @param {SubscriptionDeleteCommunityAlertRequest} subscriptionDeleteCommunityAlertRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    subscriptionDeleteCommunityAlert(
      addressId: string,
      id: number,
      subscriptionDeleteCommunityAlertRequest: SubscriptionDeleteCommunityAlertRequest,
      options?: any,
    ): AxiosPromise<number> {
      return localVarFp
        .subscriptionDeleteCommunityAlert(
          addressId,
          id,
          subscriptionDeleteCommunityAlertRequest,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} addressId
     * @param {number} id
     * @param {SubscriptionDeleteThreadSubscriptionRequest} subscriptionDeleteThreadSubscriptionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    subscriptionDeleteThreadSubscription(
      addressId: string,
      id: number,
      subscriptionDeleteThreadSubscriptionRequest: SubscriptionDeleteThreadSubscriptionRequest,
      options?: any,
    ): AxiosPromise<number> {
      return localVarFp
        .subscriptionDeleteThreadSubscription(
          addressId,
          id,
          subscriptionDeleteThreadSubscriptionRequest,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} addressId
     * @param {number} id
     * @param {SubscriptionRegisterClientRegistrationTokenRequest} subscriptionRegisterClientRegistrationTokenRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    subscriptionRegisterClientRegistrationToken(
      addressId: string,
      id: number,
      subscriptionRegisterClientRegistrationTokenRequest: SubscriptionRegisterClientRegistrationTokenRequest,
      options?: any,
    ): AxiosPromise<object> {
      return localVarFp
        .subscriptionRegisterClientRegistrationToken(
          addressId,
          id,
          subscriptionRegisterClientRegistrationTokenRequest,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} addressId
     * @param {number} id
     * @param {SubscriptionRegisterClientRegistrationTokenRequest} subscriptionRegisterClientRegistrationTokenRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    subscriptionUnregisterClientRegistrationToken(
      addressId: string,
      id: number,
      subscriptionRegisterClientRegistrationTokenRequest: SubscriptionRegisterClientRegistrationTokenRequest,
      options?: any,
    ): AxiosPromise<object> {
      return localVarFp
        .subscriptionUnregisterClientRegistrationToken(
          addressId,
          id,
          subscriptionRegisterClientRegistrationTokenRequest,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} addressId
     * @param {number} id
     * @param {SubscriptionUpdateSubscriptionPreferencesRequest} subscriptionUpdateSubscriptionPreferencesRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    subscriptionUpdateSubscriptionPreferences(
      addressId: string,
      id: number,
      subscriptionUpdateSubscriptionPreferencesRequest: SubscriptionUpdateSubscriptionPreferencesRequest,
      options?: any,
    ): AxiosPromise<SubscriptionGetSubscriptionPreferences200ResponseAnyOf> {
      return localVarFp
        .subscriptionUpdateSubscriptionPreferences(
          addressId,
          id,
          subscriptionUpdateSubscriptionPreferencesRequest,
          options,
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * SubscriptionApi - object-oriented interface
 * @export
 * @class SubscriptionApi
 * @extends {BaseAPI}
 */
export class SubscriptionApi extends BaseAPI {
  /**
   *
   * @param {string} addressId
   * @param {number} id
   * @param {SubscriptionCreateCommentSubscriptionRequest} subscriptionCreateCommentSubscriptionRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SubscriptionApi
   */
  public subscriptionCreateCommentSubscription(
    addressId: string,
    id: number,
    subscriptionCreateCommentSubscriptionRequest: SubscriptionCreateCommentSubscriptionRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return SubscriptionApiFp(this.configuration)
      .subscriptionCreateCommentSubscription(
        addressId,
        id,
        subscriptionCreateCommentSubscriptionRequest,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} addressId
   * @param {number} id
   * @param {SubscriptionCreateCommunityAlertRequest} subscriptionCreateCommunityAlertRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SubscriptionApi
   */
  public subscriptionCreateCommunityAlert(
    addressId: string,
    id: number,
    subscriptionCreateCommunityAlertRequest: SubscriptionCreateCommunityAlertRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return SubscriptionApiFp(this.configuration)
      .subscriptionCreateCommunityAlert(
        addressId,
        id,
        subscriptionCreateCommunityAlertRequest,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} addressId
   * @param {number} id
   * @param {SubscriptionCreateThreadSubscriptionRequest} subscriptionCreateThreadSubscriptionRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SubscriptionApi
   */
  public subscriptionCreateThreadSubscription(
    addressId: string,
    id: number,
    subscriptionCreateThreadSubscriptionRequest: SubscriptionCreateThreadSubscriptionRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return SubscriptionApiFp(this.configuration)
      .subscriptionCreateThreadSubscription(
        addressId,
        id,
        subscriptionCreateThreadSubscriptionRequest,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} addressId
   * @param {number} id
   * @param {SubscriptionDeleteCommentSubscriptionRequest} subscriptionDeleteCommentSubscriptionRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SubscriptionApi
   */
  public subscriptionDeleteCommentSubscription(
    addressId: string,
    id: number,
    subscriptionDeleteCommentSubscriptionRequest: SubscriptionDeleteCommentSubscriptionRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return SubscriptionApiFp(this.configuration)
      .subscriptionDeleteCommentSubscription(
        addressId,
        id,
        subscriptionDeleteCommentSubscriptionRequest,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} addressId
   * @param {number} id
   * @param {SubscriptionDeleteCommunityAlertRequest} subscriptionDeleteCommunityAlertRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SubscriptionApi
   */
  public subscriptionDeleteCommunityAlert(
    addressId: string,
    id: number,
    subscriptionDeleteCommunityAlertRequest: SubscriptionDeleteCommunityAlertRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return SubscriptionApiFp(this.configuration)
      .subscriptionDeleteCommunityAlert(
        addressId,
        id,
        subscriptionDeleteCommunityAlertRequest,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} addressId
   * @param {number} id
   * @param {SubscriptionDeleteThreadSubscriptionRequest} subscriptionDeleteThreadSubscriptionRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SubscriptionApi
   */
  public subscriptionDeleteThreadSubscription(
    addressId: string,
    id: number,
    subscriptionDeleteThreadSubscriptionRequest: SubscriptionDeleteThreadSubscriptionRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return SubscriptionApiFp(this.configuration)
      .subscriptionDeleteThreadSubscription(
        addressId,
        id,
        subscriptionDeleteThreadSubscriptionRequest,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} addressId
   * @param {number} id
   * @param {SubscriptionRegisterClientRegistrationTokenRequest} subscriptionRegisterClientRegistrationTokenRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SubscriptionApi
   */
  public subscriptionRegisterClientRegistrationToken(
    addressId: string,
    id: number,
    subscriptionRegisterClientRegistrationTokenRequest: SubscriptionRegisterClientRegistrationTokenRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return SubscriptionApiFp(this.configuration)
      .subscriptionRegisterClientRegistrationToken(
        addressId,
        id,
        subscriptionRegisterClientRegistrationTokenRequest,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} addressId
   * @param {number} id
   * @param {SubscriptionRegisterClientRegistrationTokenRequest} subscriptionRegisterClientRegistrationTokenRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SubscriptionApi
   */
  public subscriptionUnregisterClientRegistrationToken(
    addressId: string,
    id: number,
    subscriptionRegisterClientRegistrationTokenRequest: SubscriptionRegisterClientRegistrationTokenRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return SubscriptionApiFp(this.configuration)
      .subscriptionUnregisterClientRegistrationToken(
        addressId,
        id,
        subscriptionRegisterClientRegistrationTokenRequest,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} addressId
   * @param {number} id
   * @param {SubscriptionUpdateSubscriptionPreferencesRequest} subscriptionUpdateSubscriptionPreferencesRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SubscriptionApi
   */
  public subscriptionUpdateSubscriptionPreferences(
    addressId: string,
    id: number,
    subscriptionUpdateSubscriptionPreferencesRequest: SubscriptionUpdateSubscriptionPreferencesRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return SubscriptionApiFp(this.configuration)
      .subscriptionUpdateSubscriptionPreferences(
        addressId,
        id,
        subscriptionUpdateSubscriptionPreferencesRequest,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @param {string} addressId
     * @param {number} id
     * @param {UserUpdateUserRequest} userUpdateUserRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userUpdateUser: async (
      addressId: string,
      id: number,
      userUpdateUserRequest: UserUpdateUserRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'addressId' is not null or undefined
      assertParamExists('userUpdateUser', 'addressId', addressId);
      // verify required parameter 'id' is not null or undefined
      assertParamExists('userUpdateUser', 'id', id);
      // verify required parameter 'userUpdateUserRequest' is not null or undefined
      assertParamExists(
        'userUpdateUser',
        'userUpdateUserRequest',
        userUpdateUserRequest,
      );
      const localVarPath = `/UpdateUser/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (addressId != null) {
        localVarHeaderParameter['address_id'] = String(addressId);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        userUpdateUserRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {string} addressId
     * @param {number} id
     * @param {UserUpdateUserRequest} userUpdateUserRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async userUpdateUser(
      addressId: string,
      id: number,
      userUpdateUserRequest: UserUpdateUserRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<UserUpdateUser200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.userUpdateUser(
        addressId,
        id,
        userUpdateUserRequest,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['UserApi.userUpdateUser']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = UserApiFp(configuration);
  return {
    /**
     *
     * @param {string} addressId
     * @param {number} id
     * @param {UserUpdateUserRequest} userUpdateUserRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userUpdateUser(
      addressId: string,
      id: number,
      userUpdateUserRequest: UserUpdateUserRequest,
      options?: any,
    ): AxiosPromise<UserUpdateUser200Response> {
      return localVarFp
        .userUpdateUser(addressId, id, userUpdateUserRequest, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
  /**
   *
   * @param {string} addressId
   * @param {number} id
   * @param {UserUpdateUserRequest} userUpdateUserRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public userUpdateUser(
    addressId: string,
    id: number,
    userUpdateUserRequest: UserUpdateUserRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return UserApiFp(this.configuration)
      .userUpdateUser(addressId, id, userUpdateUserRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
